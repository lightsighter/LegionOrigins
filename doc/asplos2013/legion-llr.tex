\documentclass{sig-alternate}

\bibliographystyle{plainnat}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{listings}
\usepackage{tikz}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage{dcolumn}
\usepackage{cancel}

\newcommand{\infrule}[2]{\displaystyle\frac{\displaystyle\strut{#1}}{\displaystyle\strut {#2}}}
\newcommand{\deref}{\ast}
\newcommand{\rread}[1]{\mbox{\em Read}(#1)}
\newcommand{\rwrite}[1]{\mbox{\em Write}(#1)}
\newcommand{\lca}[2]{#1 \sqcup #2}
\newcommand{\rleq}{\leq}
\newcommand{\interval}[1]{\mbox{\em interval}(#1)}
\newcommand{\context}[1]{\mbox{\em context}(#1)}
\newtheorem{theorem}{Theorem} 
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}

\title{Asynchronous High-Performance Language Primitives for Distributed Heterogeneous Architectures}
\numberofauthors{3}
\author{}
\maketitle

\begin{abstract}
%The limit is 12 pages, including bibliography and appendices.
%Deadlines:
%\begin{tabular}{ll}
%Abstract deadline & July 16, 2012 3pm PDT \\
%Paper deadline & July 23, 2012 3pm PDT \\
%Author response & around October 15, 2012 \\
%Author notification & November 9, 2012
%\end{tabular}
Modern parallel architectures are composed of both heterogeneous processors
and complex distributed memory hierarchies.  We present a low-level programming
interface that provides simple primitives for targeting this class of
machines.  Our interface includes mechanisms for the creation and movement
of data through the memory hierarchy as well as a novel synchronization primitive 
called a deferred lock.  To hide the large latencies associated with the target
set of machines the interface is made asynchronous via an event system.  All
operations return an event to be triggered when the operation completes.  Events
can be chained together and used to create dependences between operations.
We describe an implementation of our interface capable of running on
a large supercomputer with both CPU and GPU processors and a high speed interconnect.
We employ several micro-benchmarks to show that our implementation approaches
the performance limits of the underlying hardware.
We also demonstrate that the interface is sufficiently powerful to serve as the foundation 
of an advanced runtime system.  We measure the performance of three real-world applications
that use our system on the Keeneland supercomputer.
\end{abstract}

\section{Introduction}
\label{sect:intro}
Introduction goes here.

\input{outline}

\input{conclusion}

{
\small
\bibliography{bibliography}
}

\end{document}


