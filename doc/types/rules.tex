
\documentclass{article}

\usepackage[cmex10]{amsmath}
\usepackage{listings}

\newcommand{\infrule}[2]{\displaystyle\frac{\displaystyle\strut{#1}}{\displaystyle\strut {#2}}}
\newcommand{\cinfrule}[3]{\parbox{14cm}{\hfil$\infrule{#1}{#2}$\hfil}\parbox{4cm}{$\,#3$\hfil}}

\begin{document}

\begin{table*}
\centering
{\small
\begin{tabular}{ccc}
$program$ & ::= & $fn^*$ \\
$fn$ & ::= & $f(x_1, \ldots, x_n)$ $e$ \\
\end{tabular}
}
\caption{Program and Functions}
\end{table*}


\begin{table*}
\centering
{\small
\begin{tabular}{cc}
%
% Statement composition
%
\begin{math}
\infrule{
\begin{array}{lc}
	\Gamma \vdash e_1 : T_1, C_1 \\
	\Gamma \vdash e_2 : T_2, C_2 
\end{array}
}
{
	\Gamma \vdash e_1; e_2 : T_2, (C_1 \wedge C_2)
}
\end{math} 
&\raisebox{-0.2in}{[{\tt Composition}]} \\

%
% Conditional statement
%
\begin{math}
\infrule{
\begin{array}{lc}
	\Gamma \vdash e_1 : Int, C_1 \\
	\Gamma \vdash e_2 : T, C_2 \\
	\Gamma \vdash e_3 : T, C_3
\end{array}
}
{
	\Gamma \vdash\textrm{ if }e_1\textrm{ then }e_2\textrm{ else }e_3 : T, (C_1 \wedge C_2 \wedge C_3)
}
\end{math}
&\raisebox{-0.2in}{[{\tt Conditional}]} \\
%
% While Statement
%
\begin{math}
\infrule{
\begin{array}{lc}
	\Gamma \vdash e_1 : Int, C_1 \\
	\Gamma \vdash e_2 : T, C_2
\end{array}
}
{
	\Gamma \vdash\textrm{ while }e_1\textrm{ do }e_2 : T, (C_1 \wedge C_2) 
% TODO: fix this - while can't return something of type T if the initial condition test fails!
}
\end{math}
&\raisebox{-0.2in}{[{\tt While}]} \\
%
% Assignment statement
%
\begin{math}
\infrule
{
\begin{array}{lc}
	\Gamma, x : T \vdash e_1 : T / C
\end{array}
}
{
	\Gamma \vdash x = e_1 : T / C
}
\end{math}
&\raisebox{-0.2in}{[{\tt Assignment}]} \\
\end{tabular}
}
\caption{Statements}
\end{table*}

\begin{table*}
\centering
{\small
\begin{tabular}{cc}

%
% Variables
%
\begin{math}
\infrule
{
}
{
	\vdash x:T / C
}
\end{math} 
&\raisebox{-0.2in}{[{\tt Variable}]} \\

%
% Integers
%
\begin{math}
\infrule
{
}
{
	\vdash i : Int / \top
}
\end{math} 
&\raisebox{-0.2in}{[{\tt Integer Literal}]} \\

%
% Tuples
%
\begin{math}
\infrule
{
\begin{array}{lc}
	\vdash e_1 : T_1 / C_1 \\
	\ldots \\
	\vdash e_n : T_n / C_n
\end{array}
}
{
	\vdash \langle e_1, \ldots, e_n \rangle : \langle T_1, \ldots, T_n \rangle / (C_1 \wedge \ldots \wedge C_n)
}
\end{math}
&\raisebox{-0.2in}{[{\tt Tuple}]}  \\

%
% Field Access
%
\begin{math}
\infrule
{
\begin{array}{lc}
	\vdash e : T_1 / C_1 \\
	\vdash x \in T_1 \\
	\vdash x : T_2 / C_2
\end{array}
}
{
	\vdash e.x : T_2 / (C_1 \wedge C_2)
}
\end{math} 
&\raisebox{-0.2in}{[{\tt Field Access}]} \\

%
% Lambda
%
\begin{math}
\infrule
{
\begin{array}{lc}
        \Gamma, x : T_1 \vdash e : T_2 / C
\end{array}
}
{
        \Gamma \vdash \lambda x.e : T_1 \rightarrow T_2 / C, \emptyset
}
\end{math}
&\raisebox{-0.2in}{[{\tt Lambda}]} \\

%
% Function application
%
\begin{math}
\infrule
{
\begin{array}{lc}
        \Gamma \vdash e_1 : T_1 \rightarrow T_2 / C_1, C_2 \\
	\Gamma \vdash e_2 : T_1 / C_3
\end{array}
}
{
	\Gamma \vdash e_1 e_2 : T_2 / (C_1 \wedge C_2 \wedge C_3)
}
\end{math}
&\raisebox{-0.2in}{[{\tt Function Application}]} \\ 

%
% Pack
%
\begin{math}
\infrule
{
\begin{array}{lc}
        RR = \exists r_1, \ldots, r_n, T_1 / C_1 \\
        \Gamma \vdash e : [r'_1/r1,...r'_n/r_n]T_1, C_2 \\
        C_2 \models [r'_1/r1, \ldots, r'_n/r_n]C_1
\end{array}
}
{
        \Gamma \vdash\textrm{ packrr }RR\mbox{ }e : RR, C_2
}
\end{math}
&\raisebox{-0.2in}{[{\tt Pack}]} \\

%
% Unpack
%
\begin{math}
\infrule
{
\begin{array}{lc}
        RR = \exists r_1, \ldots, r_n, T_1 / C_1 \\
        \Gamma \vdash e : RR, C_2 \\
        r'_1, \ldots, r'_n \not\in \Gamma
\end{array}
}
{
        \Gamma \vdash\textrm{ unpackrr }e : [r'_1/r_1, \ldots, r'_n/r_n]T_1, (C_1 \wedge [r'_1/r_1, \ldots, r'_n/r_n]C_2)
}
\end{math}
&\raisebox{-0.2in}{[{\tt Unpack}]}

\end{tabular}
}
\caption{Expressions}
\end{table*}

%%%%%%%%%%%%%%%%%
% Operations on Region Elements
%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{cc}
%
% Read Region
% 
\begin{math}
read : \forall T,r_1,r_2. \langle Region(r_1,T), T@r_2 \rangle \rightarrow T / (readable(r_1) \wedge r_2 \le r_1)
\end{math} & [{\tt Read Pointer}] \\

%
% Write Region
%
\begin{math}
write : \forall T,r_1,r_2. \langle Region(r_1,T), T@r_2, T \rangle \rightarrow () / (writeable(r_1) \wedge r_2 \le r_1)
\end{math} & [{\tt Write Pointer}] \\

%
% Reduce Region
%
\begin{math}
reduce : \forall T,r_1,r_2. \big( \forall f:(T \rightarrow T \rightarrow T).  \langle Region(r_1,T), T@r_2, f, T \rangle \rightarrow () / (reduceable(r_1,f) \wedge r_2 \le r_1) \big)
\end{math} & [{\tt Reduce Pointer}] \\

%
% Alloc 
%
\begin{math}
alloc : \forall T,r. \langle Region(r,T) \rangle \rightarrow T@r / allocable(r)
\end{math} & [{\tt Alloc Pointer}] \\

%
% Free
%
\begin{math}
free : \forall T,r. \langle Region(r,T), T@r \rangle \rightarrow () / freeable(r)
\end{math} & [{\tt Free Pointer}] 

\end{tabular}
}
\caption{Predefined Functions on Region Elements}
\end{table*}

%%%%%%%%%%%%%%%%%%%
% Operations on Regions
%%%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{cc}

%
% Partition
%
\begin{math}
partition : \forall T,r. \langle Region(r,T), (T@r \rightarrow Int) \rangle \rightarrow Partition(r) / readable(r)
\end{math} & [{\tt Partition}] \\

%
% Subregion
%
\begin{math}
\begin{array}{lc}
subregion : \forall T,r. \bigg( \exists r_1, \ldots, r_n . \langle Partition(r), \langle i_1, \ldots, i_n \rangle \rangle \rightarrow \\
	\Big( \langle Region(r_1,T), \ldots, Region(r_n,T) \rangle / \big((\forall j,k. r_j * r_k) \wedge (\forall j. [r_j \le r])\big)\Big) / (\bigwedge_{j,k = 1, \ldots, n, j \ne k} i_j \ne i_k) \bigg)
\end{array}
\end{math} & [{\tt Subregion}] \\

%
% Smash
%
\begin{math}
smash : \forall T,r_1,\ldots,r_n,r_p. \exists r'. \langle Region(r_1,T), \ldots, Region(r_n,T) \rangle \rightarrow \big(Region(r\prime,T) / (r\prime \le r_p)\big) / (\bigwedge_{i = 1, \ldots, n} r_i \le r_p)
\end{math} & [{\tt Smash}] \\

\end{tabular}
}
\caption{Predefined Functions on Regions}
\end{table*}

%%%%%%%%%%%%%%%%%%%%
% Operations on Region Relationships
%%%%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{cc}

%
% New
%
\begin{math}
newRR : () \rightarrow RR
\end{math} & [{\tt New RR}] \\

%
% Delete
%
\begin{math}
deleteRR : \forall RR.RR \rightarrow ()
\end{math} & [{\tt Delete RR}] \\
\end{tabular}
}
\caption{Predefined Functions on Region Relationships}
\end{table*}

%%%%%%%%%%%%%%%%%%
% Types
%%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{ccc}

T & ::= & Int \\
  &$\mid$&$\langle T_1, \ldots, T_n \rangle$ \\
  &$\mid$&$T_1 \rightarrow T_2$ \\
  &$\mid$&$T@r$\\
  &$\mid$&$\forall t.T$ \\
  &$\mid$&$\forall r.T/C$ \\
  &$\mid$&$RR$ \\
  &$\mid$&$Region(r,T)$ \\
  &$\mid$&$Partition(r)$ \\

\end{tabular}
}
\caption{Types}
\end{table*}

%%%%%%%%%%%%%%%%%%
% Region Relationship Types
%%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{ccc}
RR & ::= & $\exists r.T/C$ \\
\end{tabular}
}
\caption{Region Relationship Types}
\end{table*}



%%%%%%%%%%%%%%%%%%%%
% Constraints
%%%%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{ccc}

C & ::= & $readable(r)$ \\
  &$\mid$&$writeable(r)$ \\
  &$\mid$&$reduceable(r,f)$ \\
  &$\mid$&$allocable(r)$ \\
  &$\mid$&$freeable(r)$ \\
  &$\mid$&$(r_1 \le r_2)$ \\
  &$\mid$&$(r_1 * r_2)$ \\
  &$\mid$&$(i_1 = i_2)$ \\
  &$\mid$&$(i_1 \ne i_2)$ \\
  &$\mid$&$(C_1 \wedge C_2)$ \\
\end{tabular}
}
\caption{Constraints}
\end{table*}

%%%%%%%%%%%%%%%%%%%%
% Saturation of Constraints
%%%%%%%%%%%%%%%%%%%%
\begin{table*}
\centering
{\small
\begin{tabular}{cc}
%
% read/write-ability of subregions
%
\begin{math}
\begin{array}{c}
\forall r_1, r_2. (readable(r_1) \wedge r_2 \le r_1) \rightarrow readable(r_2) \\
\forall r_1, r_2. (writeable(r_1) \wedge r_2 \le r_1) \rightarrow writeable(r_2) \\
\forall f, r_1, r_2. (reduceable(r_1,f) \wedge r_2 \le r_1) \rightarrow reduceable(r_2,f) \\
\forall r_1, r_2. (allocable(r_1) \wedge r_2 \le r_1) \rightarrow allocable(r_2) \\
\forall r_1, r_2. (freeable(r_1) \wedge r_2 \le r_1) \rightarrow freeable(r_2)
\end{array}
\end{math} & [{\tt Subregion Accessibility }] \\
\\
\begin{math}
\begin{array}{c}
\forall r, f_1, f_2. (reduceable(r,f_1) \wedge reduceable(r,f_2) \wedge f_1 \ne f_2) \rightarrow (readable(r) \wedge writeable(r)) \\
\forall r, f. (readable(r) \wedge writeable(r)) \rightarrow reduceable(r,f) 
\end{array}
\end{math} & [{\tt Reduction Incompatibility}] \\
\\
%
% reflexivity/transitivity of subregion relationship
%
\begin{math}
\begin{array}{c}
\forall r, r \le r \\
\forall r_1, r_2, r_3. (r_1 \le r_2 \wedge r_2 \le r_3) \rightarrow r_1 \le r_3
\end{array}
\end{math} & [{\tt Subregion Relationships}] \\
\\
\begin{math}
\forall r_1, r_2, r_3. (r_1 \le r_2 \wedge r_2 * r_3) \rightarrow r_1 * r_3
\end{math} & [{\tt Subregion Disjointness}] \\
\\
\begin{math}
\forall r_1, r_2. r_1 * r_2 \rightarrow r_2 * r_1
\end{math} & [{\tt Disjointness Symmetry}]
\end{tabular}
}
\caption{Constraint Inference Rules}
\end{table*}

\end{document}
