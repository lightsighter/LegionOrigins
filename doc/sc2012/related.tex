
\section{Related Work}
\label{sec:related}

Legion began as an outgrowth of Sequoia, a locality-aware programming language capable
of expressing computations in deep memory hierarchies
\cite{Fatahalian06}.  Sequoia is a special case of the Legion
programming model in which only arrays can be recursively partitioned,
all access is exclusive, there is a static mapping of tasks and data (though
extensions to Sequoia make this mapping more dynamic \cite{BCSA11}) and, most fundamentally, the decomposition of tasks and the decomposition
of data is one-to-one.  Legion generalizes the Sequoia model by allowing for
dynamic partitioning of pointer data structures through regions, enabling dynamic mappings through
the mapper interface, and allowing different coherence
properties.  Legion's decoupling of the task tree from the region tree leads directly to the scheduling problem solved by our software out-of-order processor for tasks with region arguments.

Chapel has several concepts to support the expression of locality \cite{Chamberlain:Chapel}.
Domains are similar to logical regions in that they describe maps from indexes
to objects.  Domains can create sub-domains by slicing the index sets from
a parent domain.  Domains are a higher level concept than regions; the domain index sets 
support dimensionality and iterators, whereas logical regions can only be accessed by pointers.  
Also, the act of creating subdomains in Chapel does not track disjointness information,
making it more challenging for the Chapel compiler or runtime to infer task independence.

In addition to domains, Chapel also supports the notion of domain maps and locales to enable 
the programmer to efficiently map domains onto hardware \cite{CHAPEL11}.  Locales are a flat array
of abstract locations.  Programmers can use locales by writing domain maps that specify
how domains are subdivided and assigned to locales.  Domain maps provide the same functionality
as partitions and mappers in Legion, but require the user to correctly implement domain
maps for the program to be correct.  Legion explicitly isolates correctness
from performance by defining the Mapper interface.  In addition, Chapel's flat array of locales
makes it challenging to fully utilize deep memory hierarchies.  Chapel currently supports
clusters and GPUs in isolation \cite{CHAPELGPU}, but we are not aware of any results that 
make use of both.

X10 is another parallel programming language designed to operate on
distributed memory machines \cite{X1005}.  X10's {\em places} enable
programmers to talk about where to place both data and tasks.
However, once data and tasks have been placed they are fixed, which
mandates that data movement be explicitly managed by user level code
or implicitly by the compiler or runtime \cite{X1008}.  Recently X10
has introduced regions into the compiler's
intermediate representation \cite{X1011}.  Unlike Legion, regions in
X10 are not visible to the programmer but are inferred from high level
arrays through static analysis.  X10 provides support for clusters of
GPUs \cite{X10GPU}, but requires the programmer to write all code
managing data movement through both the cluster and GPU memory
hierarchies.

Deterministic Parallel Java (DPJ) is a parallel extension of Java
that, like Legion, uses regions to express locality and does
dependence analysis at the granularity of conflicts on region
arguments to functions \cite{Bocchino09}.  As the name suggests, one
of the primary goals of DPJ is to provide a programming model that
guarantees determinism while also supporting parallelism.
As a result the programming model is more restrictive than Legion, as
there is no notion of weaker coherence properties of regions than
exclusive access (which is essential to determinism).  DPJ can express
the populate-then-partition style of using regions, but not the
partition-then-populate; overall, the language is more static, and
thus provides more guarantees and less flexibility than Legion.  
DPJ efforts have so far focused on JVM implementations on shared memory machines.
There have also been several other recent efforts that propose task schedulers
based on dynamic detection of memory conflicts, but these also have assumed
underlying shared memory hardware \cite{VTN11,Tzenakis12,EYJD12}.

SPMD languages such as Titanium \cite{TIT98} and UPC \cite{UPC99} have
mechanisms for describing array partitions in distributed memories.
However, the partition operations supported only operate on two-level
memory hierarchies consisting of local and global memory. 
% Neither
%Titanium nor UPC currently support GPUs as part of their language
%standard \cite{TITANIUMSTANDARD} \cite{UPCSTANDARD}.  
Part of Legion's
low-level runtime system is constructed using UPC's GASNet
runtime system \cite{GASNET07}.


In previous programming systems regions have primarily been used as a construct for
describing memory management schemes \cite{REAPS02,RC01}  
or for enforcing safety policies \cite{CYCLONE01}.  We follow \cite{RC01} in Legion's
decision to make regions first class.  In these works, however, regions have
memory layout implications.  Logical regions in Legion enable the programmer to
describe locality independent of memory layout.

%Marino introduces a generic flow-insensitive type-effect system capable of verifying 
%accesses to statically tagged locations of memory \cite{PRIVLIGES09}.  Legion's programming
%system allows for dynamic creation and partitioning of regions requiring a 
%flow-sensitive analysis to track privileges.
