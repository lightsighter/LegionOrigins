
\section{Related Work}
\label{sec:related}

Legion is an outgrowth of previous work on Sequoia, a locality-aware programming language capable
of expressing computations in deep memory hierarchies
\cite{Fatahalian06}.  Sequoia is a special case of the Legion
programming model in which only arrays can be recursively partitioned,
all access is exclusiv, there is a static mapping of tasks and data on to the machine (though
extensions to Sequoia make this mapping more dynamic \cite{BCSA11}) and, most fundamentally, the decomposition of tasks and the decomposition
of data is one-to-one.  Legion generalizes the Sequoia model by allowing for
partitioning of pointer data structures through regions, enabling dynamic mappings through
the mapper interface, and allowing different coherence
properties.  Legion's decoupling of the task tree from the region tree in Legion leads directly to the scheduling problem solved by our software out-of-order processor for tasks with region arguments.

Chapel has several concepts to support the expression of locality \cite{Chamberlain:Chapel}.
Domains are similar to logical regions in that they describe maps from indexes
to same-typed objects.  Domains can create sub-domains by slicing the index sets from
a parent domain.  Domains are a higher level concept than regions; the domain index sets 
support dimensionality and iterators, whereas  logical regions can only be accessed by pointers.  
Second, the act of creating subdomains in Chapel does not track disjointness information,
making it more challenging for the Chapel compiler or runtime to infer task independence.

In addition to domains, Chapel also supports the notion of domain maps and locales to enable 
the programmer to efficiently map domains onto hardware \cite{CHAPEL11}.  Locales are a flat array
of abstract locations.  Programmers can use locales by writing domain maps that specify
how domains are subdivided and assigned to locales.  Domain maps provide the same functionality
as partitions and mappers in Legion, but require the user to correctly implement domain
maps for the program to be correct.  Legion explicitly isolates correctness
from performance by defining the Mapper interface.  In addition, Chapel's flat array of locales
makes it challenging to fully utilize deep memory hierarchies.  Chapel currently supports
clusters and GPUs in isolation \cite{CHAPELGPU}, but we are not aware of any results that 
make use of both.

X10 is another parallel programming environment designed to operate on distributed
memory machines \cite{X1005}.  X10's {\em places} enable programmers to talk about where
to place both data and tasks in the machine.  However, once data and tasks have
been placed they are fixed, which mandates that data movement be explicitly managed by
user level code or implicitly by the compiler or runtime \cite{X1008}.  Recently X10 has introduced
the concept of a region into the compiler's intermediate representation \cite{X1011}.
Unlike Legion, regions in X10 are not visible to the programmer but are inferred
from high level arrays through static analysis.  X10 provides support for clusters of GPUs
\cite{X10GPU}, but requires the programmer to write all code managing data movement
through both the cluster and GPU memory hierarchies.

Deterministic Parallel Java (DPJ) is a parallel extension of Java
that, like Legion, uses regions to express locality and does
dependence analysis at the granularity of conflicts on region
arguments to functions \cite{Bocchino09}.  As the name suggests, one
of the primary goals of DPJ is to provide a programming model that
guarantees determinism while also providing supporting parallelism.
As a result the programming model is more restrictive than Legion, as
there is no notion of weaker coherence properties of regions than
exclusive access (which is essential to determinism).  DPJ can express
the populate-then-partition style of using regions, but not the
partition-then-populate; overall, the language is more static, and
thus provides more guarantees and less flexibility than Legion.  Most
significantly, however, DPJ efforts have so far focused on JVM
implementations on on shared memory machines; there is nothing
corresponding to our distributed software out-of-order processor or
the mapping interface.

SPMD languages such as Titanium \cite{TIT98} and UPC \cite{UPC99} have
mechanisms for describing array partitions in distributed memories.
However, the partition operations supported only operate on two-level
memory hierarchies consisting of local and global memory. 
% Neither
%Titanium nor UPC currently support GPUs as part of their language
%standard \cite{TITANIUMSTANDARD} \cite{UPCSTANDARD}.  
Part of Legion's
low-level runtime system is constructed using UPC's underlying GASNet
runtime system \cite{GASNET07}.


In previous programming systems regions have primarily been used as a construct for
describing memory management schemes \cite{REAPS02}\cite{RC01}  
or for enforcing safety policies \cite{CYCLONE01}.  In all cases, regions had
memory layout implications.  Logical regions in Legion enable the programmer to
describe locality and independence without any memory layout implications.

%Marino introduces a generic flow-insensitive type-effect system capable of verifying 
%accesses to statically tagged locations of memory \cite{PRIVLIGES09}.  Legion's programming
%system allows for dynamic creation and partitioning of regions requiring a 
%flow-sensitive analysis to track privileges.
