
\section{Introduction}
\label{sec:intro}

In the past decade machine architecture, particularly at the high
performance end of the spectrum, has undergone a revolution.  The
latest supercomputers are now complex hierarchies of many different
kinds of computing technologies: networks of nodes at the top level,
multiple chips per node, mutiple cores within a chip, and, most
recently, multiple accelerators (usually GPUs) per node, which are
themselves can be further decomposed into several levels of machine
hierarchy.  In this paper, we present the operational and static
semantics of Legion, a programming language targeted at providing an
appropriate level of abstraction for programming such machines, one
that is both sufficiently high-level to be portable while still
exposing aspects that are crucial to performance. A very brief summary
of Legion is that data is organized in a hierarchy of {\em regions}
and subregions and computation is organized in a hierarchy of {\em
tasks} and subtasks operating on regions.  Regions and tasks interact
through a static system of {\em region permissions} specifying the
operations a task may perform on a region argument (e.g., read or
write, among others) and novel {\em region coherence} annotations that
expresses whether other tasks may perform operations concurrently on
the region (e.g., {\em exclusive} access for task $t$ guarantees no
other task's updates to a region are visible to $t$).  We prove the
soundness of the permissions and coherence system and use these two
results to prove a third result: if two tasks $t_1$ and $t_2$ are {\em
dependent} (roughly, must be executed in program order to guarantee
the correct answer), then the unique ancestors of $t_1$ and $t_2$ in
the task hierarchy that are {\em siblings} (have the same parent task)
are also dependent.  This theoremis the basis for distributed
scheduling in a Legion implementation, which is crucial for
performance; any centralized scheduler would be a severe bottleneck
because of the huge latencies involved in moving data and computation
in the target class of machines.

Legion programs organize data into {\em logical regions}.  Logical
regions (which we usually refer to simply as {\em regions}) express
{\em locality}, which is just data that will be used together and
therefore should be colocated in the machine.
Listing~\ref{lst:linkedlist} gives an example that defines a region
containing a linked list of integers and a task that sums the elements
of the list.  As is standard in region systems, we use $T @ r$ for the
type of a pointer to a value of type $T$ in region $r$.  The task also
illustrates a simple use of the permissions system; in this case the
task {\tt sum\_list} must have permission {\tt reads(r)}, the ability
to read the values in region {\tt r}.

Listing~\ref{lst:treereverse} gives a more elaborate example.  While
artificial (it is designed to use the greatest number of Legion
features in the smallest space), the program illustrates typical
Legion programming idioms.  Given a list of integers as defined in Listing~\ref{lst:linkedlist}, 
the task {\tt make\_tree} builds a binary tree of pointers to list elements.
Each internal node of the tree stores a pointer to a list element with value $i$
and the left and right subtrees hold pointers to list elements with values less than $i$ and greater than $i$,
respectively.  The task {\tt reverse\_tree} then does an in-place, recursive reversal of the children of each interior
node of the tree.  We focus on a description of the structure of types and permissions in this example.

Line 1 defines a type that is a {\em region relationship} {\tt rr[
rll, rlr, rtl, rtr]}.  Region relationships are constrained
existential types.  The {\tt tree} region relationship defines the
type of a node of the tree. The naming convention followed throughout
the example is that regions that begin with {\tt rl} name regions
holding list elements and regions that begin with {\tt rt} name
regions holding tree elements.  The most important part is the {\em
subregion} and {\em disjointness} constraints that describe the
relationships between the various regions.  Here {\tt rl} is the
region holding all list elements and {\tt rls} and {\tt rt} are the
regions holding just the list elements pointed to by and the tree
nodes included in the tree.  Note that {\tt rls} is required to be a
subregion of {\tt rl}, which means that all the values in region {\tt
rls} are also in region {\tt rl}.  The body of the {\tt tree} region
relationship declares the shape of a node of the tree, which includes
a pointer to a list element in {\tt rls} and pointers to two
subtrees. The region relation says that there exist four regions {\tt
rll, rlr, rtl}, and {\tt rtr} such that the left subtree has list and
tree elements that are in subregions {\tt rll} and {\tt rtl} of the
corresponding list and tree regions {\tt rls} and {\tt rt} for the
entire tree; the right subtree's list and tree elements in subregions
{\tt rlr} and {\tt rtr} are also subregions of {\tt rls} and {\tt rt}
respectively.  Furthermore, the constraints $\tt rll \ast rlr$ and
$\tt rtl \ast rtr$ guarantee that the left and right subtrees are
disjoint.

The {\tt make\_tree} task, which builds a {\tt tree} indexing a list
of integers, illustrates region {\em partitions}, another important
building block of Legion programs.  The region arguments to {\tt
make\_tree} are {\tt rl}, the region holding all list elements, {\tt
rls}, the subregion of {\tt rls} holding those list elements to be
indexed by this call to {\tt make\_tree}, and {\tt rt}, the region to
hold the tree itself.  Line 21 divides the list elements in {\tt rls}
into those that are less than and those that are greater than a split
value (which is arbitrarily chosen to be the value of the first
element of the list).  Partitioning is done by constructing a {\em
coloring} using the task {\tt color\_list}, which traverses the list
and for each list element $e$ in the subregion (called {\tt rs} in
{\tt color\_region}) either colors the element 1 or 2 (colors are
integers) depending on its relationship to the split value.  A
coloring is just a distinghuished function, built using the Legion
primitive {\tt color}, that maps elements of a region to integers.
When used in a {\tt partition} expression the coloring defines how to
populate new subregtions of the partitioned region.  On line 22, the
list elements in {\tt rls} are partitioned into two subregions {\tt
rll} and {\tt rlr} of list elements less than, and greater than or
equal to, the split value, respectively.  Another use of {\tt
partition} is seen on line 21 where the {\tt rt} region is partitioned
into subregions to hold the left {\tt rlt} and right {\tt rtr}
subtrees, respectively.  Because region {\tt rt} is empty at this
point (has no elements), the empty coloring function {\tt newcolor rt}
for the region {\tt rt} is given to the partitioning operation; the
two new subregions are also empty.  These examples illustrate that
partitioning can be used for two distinct, and equally important,
styles of computation: {\em allocate-then-partition}, in which a
global collection of data is created which is then divided up for
(usually parallel) processing, and {\em partition-then-allocate}, in
which a collection of empty but disjoint subregions is created and
then populated with data on which (usually parallel) processing will
take place.

Lines 26-27 illustrates {\em packing} a region relationship into the heap.
Regions are first-class values in Legion and can be stored in data structures.
Here a tree node is written to the {\tt root} pointer after being {\tt packed}.
Opertionally, the four existentially quantified regions {\tt rll, rlr, rtl} and {\tt rtr} are
stored with the tree value.  The type system guarantees statically that the packed value
satisfies the subregion and disjointness constraints declared on lines 3-4 at the point
the packed value is stored.  The advantage is that when the region relationship value is read 
from the heap and {\tt unpack} is applied (line 32) the newly introduced regions are already known to 
satisfy these constraints.  A key design decision in Legion, one that turns out to be
central to all the soundness results as well as the ability to perform distributed, parallel
scheduling of tasks, is that permissions and coherence annotations (which we have not yet discussed)
are {\em not} captured by region relationships.  When a region is stored in the heap it has no
permissions or coherence associated with it; these belong to the task.  When the region relationship
is read out of the heap and unpacked, the task must already hold permissions for an unpacked region 
to use it. Thus, on line 32, the task {\tt reverse\_tree} unpacks the region {\tt rtl} (among others).
The reads and writes of {\tt rtl} typecheck, however, because {\tt reverse\_tree} has read and
write permission for region {\tt rt} and $\tt rtl \leq rt}$ is a constraint of the region relationship (note
that the region {\tt rt} is not one of the existentially quantified regions!). 

 
 






Two of the basic properties programmers need to express in writing
programs for highly parallel, distributed machines are the {\em
locality} and {\em independence} of data. Locality identifies data
that will be used together and so should be placed in the same part of
the machine; independence identifies data sets that are disjoint and
so can be operated on in parallel.  Legion programs use {\em logical
regions} to express both.  A logical region (which we will usually
refer to as simply a {\em region} for brevity) is a
programmer-specified collection of data; we use the notation of
separating conjunction $r_1 \ast r_2$ for disjoint regions $r_1$ and
$r_2$.



%Programming
%these machines is currently done by using a heterogeneous collection
%of software technologies targeted at the individual level; a typical
%melange is MPI for the network, OpenMP for the node, and CUDA for the GPUs.



% This is a description of how the listings should be formatted.
% It can go anywhere before the listings.
\lstset{
  captionpos=b,
  language=Haskell,
  basicstyle=\scriptsize,
  numbers=left,
  numberstyle=\tiny,
  columns=fullflexible,
  stepnumber=1,
  escapechar=\#,
  keepspaces=true,
  literate={<}{{$\langle$}}1 {>}{{$\rangle$}}1,
  morekeywords={task,rr,int,bool,isnull,partition,as,downregion,upregion,reads,writes,rdwrs,reduces,read,write,reduce,using,unpack,pack,coloring,color,newcolor,atomic,simultaneous},
  deletekeywords={float,head,min,max}
}

% The linked list example
% Add float={t} to the list of options if you want the listing at the top
\begin{lstlisting}[label={lst:linkedlist},caption={Linked List Example}]
type list<r> = < int, list<r>@r >

task sum_list[r] ( l:list<r>@r ), reads(r) : int =
    if isnull(l) then 0 else
    let v : list<r> = read(l) in
        v.1 + sum_list[r](v.2)
\end{lstlisting}

% The tree example with partitioning and tree reversal
\begin{lstlisting}[float={t},label={lst:treereverse},caption={Tree Partitioning and Reversal Example}]
type tree<rl,rls,rt> = rr[rll, rlr, rtl, rtr] 
                       < list<rl>@rls, < tree<rl,rll,rtl>@rtl, tree<rl,rlr,rtr>@rtr > >
     		       where rll #$\le$# rls and rlr #$\le$# rls and rll #$*$# rlr and 
                                  rtl #$\le$# rt and rtr #$\le$# rt and rtl #$*$# rtr and rls #$\le$# rl

task color_list[r,rs] ( clr: coloring(rs), head: list<r>@r, 
                        splitval: int ), reads(r) : coloring(rs) =
    if isnull(head) then clr else
    let v : list<r> = read(head) in
    let ps : list<r>@rs = downregion(head, rs) in
        color_list[r,rs](if isnull(ps) then clr 
                                else color(clr, ps, if v.1 #$<$# splitval then 1 else 2), v.2, splitval)

task make_tree[rl,rls,rt] ( l: list<rl>@rl, min: int, 
                            max: int), reads(rl,rt), writes(rt) : tree<rl,rls,rt>@rt =
    if isnull(l) then null tree<rl,rls,rt>@rt else 
    let v : list<rl> = read(l) in
    if (v.1 #$<$# min) | (v.1 #$>$# max) then
    make_tree[rl,rls,rt](v.2, min, max) else
    let root : tree<rl,rls,rt>@rt = new tree<rl,rls,rt>@rt in
    partition rt using newcolor rt as rtl,rtr in
    partition rls using color_list[rl,rls](newcolor rls, v.2, v.1) as rll,rlr in
    let ptr : list<rl>@rls = downregion(l, rls) in
    let lhs : tree<rl,rll,rtl>@rtl = make_tree[rl,rll,rtl](v.2, min, v.1) in
    let rhs : tree<rl,rlr,rtr>@rtr = make_tree[rl,rlr,rtr](v.2, v.1, max) in
    let v2 : tree<rl,rls,rt> = pack < ptr, < lhs, rhs > > as tree<rl,rls,rt>[rll, rlr, rtl, rtr] in
        write(root, v2)

task reverse_tree[rl,rls,rt] ( root: tree<rl,rls,rt>@rt ), reads(rt), writes(rt) : tree<rl,rls,rt>@rt =
     if isnull(root) then null tree<rl,rls,rt>@rt else
     let v : tree<rl,rls,rt> = read(root) in
     unpack v as u : tree<rl,rls,t>[rll, rlr, rtl, rtr] in
     let lhs_r : tree<rl,rll,rtl>@rtl = reverse_tree[rl,rll,rtl](u.2.1) in
     let rhs_r : tree<rl,rlr,rtr>@rtr = reverse_tree[rl,rlr,rtr](u.2.2) in
     let v_r : tree<rl,rls,rt> = pack < u.1, < rhs_r, lhs_r > > as tree<rl,rls,rt>[rlr, rll, rtr, rtl] in
        write(root, v_r)
\end{lstlisting}

\begin{lstlisting}[label={lst:histogram},caption={Histogram with Reductions and Atomic Coherence}]
type hist = < int, int >

task hist_tree1[rl,rls,rt,rh] ( root: tree<rl,rls,rt>@rt, hptr: hist@rh, 
                                t : int ), reads(rt,rls,rh), writes(rh), atomic(rh) : int =
    if isnull(root) then 0 else
    let v : tree<rl,rls,rt> = read(root) in
    unpack v as u : tree<rl,rls,t>[rll, rlr, rtl, rtr] in
    let lval : list<rl> = read(u.1) in
    let hval : hist = read(hptr) in
    let hval2 : hist = if lval.1 #$<$# t then < hval.1 + 1, hval.2 >
                                     else < hval.1, hval.2 + 1 > in
    let _ : hist@rh = write(hptr, hval2) in
        1 + hist_tree1[rl,rll,rtl,rh](u.2.1, hptr, t) + hist_tree1[rl,rlr,rtr,rh](u.2.2, hptr, t)

task inc_bucket ( hval: hist, b: int ) : hist =
    if b #$<$# 2 then < hval.1 + 1, hval.2 > else < hval.1, hval.2 + 1 >

task hist_tree2[rl,rls,rt,rh] ( root: tree<rl,rls,rt>@rt, hptr: hist@rh, 
                                t : int ), reads(rt,rls), reduces(inc_bucket, rh) : int =
    if isnull(root) then 0 else
    let v : tree<rl,rls,rt> = read(root) in
    unpack v as u : tree<rl,rls,t>[rll, rlr, rtl, rtr] in
    let lval : list<rl> = read(u.1) in
    let _ : hist@rh = reduce(inc_bucket, hptr, if lval.1 #$<$# t then 1 else 2) in
        1 + hist_tree1[rl,rll,rtl,rh](u.2.1, hptr, t) + hist_tree1[rl,rlr,rtr,rh](u.2.2, hptr, t)
\end{lstlisting}
