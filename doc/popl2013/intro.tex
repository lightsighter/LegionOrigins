

% This is a description of how the listings should be formatted.
% It can go anywhere before the listings.
\lstset{
  captionpos=b,
  language=Haskell,
  basicstyle=\scriptsize,
  numbers=left,
  numberstyle=\tiny,
  columns=fullflexible,
  stepnumber=1,
  escapechar=\#,
  keepspaces=true,
  literate={<}{{$\langle$}}1 {>}{{$\rangle$}}1,
  morekeywords={task,rr,int,bool,isnull,partition,as,downregion,upregion,reads,writes,rdwrs,reduces,read,write,reduce,using,unpack,pack,coloring,color,newcolor,atomic,simultaneous},
  deletekeywords={float,head,min,max}
}

\section{Introduction}
\label{sec:intro}

In the past decade machine architecture, particularly at the high
performance end of the spectrum, has undergone a revolution.  The
latest supercomputers are now complex hierarchies of many different
kinds of computing technologies: networks of nodes at the top level,
multiple chips per node, mutiple cores within a chip, and, most
recently, multiple accelerators (usually GPUs) per node, which 
can themselves be decomposed into several levels.   We present the operational and static
semantics of Legion, a programming model targeted at providing an
appropriate level of abstraction for programming such machines, one
that is both sufficiently high-level to be portable while still
exposing aspects that are crucial to performance. 

In Legion data is organized in a hierarchy of {\em regions}
and subregions while computation is organized in a hierarchy of {\em
tasks} and subtasks operating on regions.  Regions and tasks interact
through a static system of {\em region permissions} specifying 
operations a task may perform on a region argument (read,
write, or reduce) and  {\em region coherence} annotations that
express what other tasks may do concurrently with
the region (exclusive, atomic, or simultaneous).  We prove the
soundness of the permissions and coherence system and use these two
results to prove a third result: if two {\em siblings} (tasks that
have the same immediate parent task) $t_1$ and $t_2$ are 
{\em independent} (have no ordering requirements for correctness), 
then the unique ancestors of $t_1$ and $t_2$ in the task hierarchy 
are also independent.  This theorem is the basis for correct distributed
task scheduling in a Legion implementation, which is crucial for
performance; a centralized scheduler would be a bottleneck
because of the huge latencies involved in communicating in the target
class of machines.


\lstset{
  captionpos=b,
  language=C++,
  basicstyle=\scriptsize,
  numbers=left,
  numberstyle=\tiny,
  columns=fullflexible,
  stepnumber=1,
  escapechar=\#,
  keepspaces=true,
  literate={<}{{$\langle$}}1 {>}{{$\rangle$}}1,
  morekeywords={region,coloring,partition,spawn,disjoint,aliased},
  deletekeywords=float,
}
\begin{lstlisting}[float={t},label={lst:code_ex},caption={Circuit simulation.}]
struct Node { float voltage, new_charge, capacitance; };
struct Wire<rn> { Node@rn in_node, out_node; float current, ... ; };
struct Circuit { region   r_all_nodes; /* contains all nodes for the circuit */
                 region   r_all_wires; /* contains all circuit wires */ };
struct CircuitPiece {
  region  rn_pvt, rn_shr, rn_ghost; /* private, shared, ghost node regions */
  region  rw_pvt;                   /* private wires region */ };

void simulate_circuit(Circuit c, float dt) : RWE(c.r_all_nodes, c.r_all_wires)
{
  // The construction of the colorings is not shown.  The colorings wire_owner_map,
  // node_owner_map, and node_neighbor_map have MAX_PIECES colors 
  // 0..MAX_PIECES #$-$# 1. The coloring node_sharing map has two colors 0 and 1.
  //
  // Partition of wires into MAX_PIECES pieces
  partition<disjoint> p_wires = c.r_all_wires.partition(wire_owner_map); 
  // Partition nodes into two parts for all-private vs. all-shared
  partition<disjoint> p_nodes_pvs = c.r_all_nodes.partition(node_sharing map);

  // Partition all-private into MAX_PIECES disjoint circuit pieces
  partition<disjoint> p_pvt_nodes = p_nodes_pvs[0].partition(node_owner_map);
  // Partition all-shared into MAX_PIECES disjoint circuit pieces
  partition<disjoint> p_shr_nodes = p_nodes_pvs[1].partition(node_owner_map);
  // Partition all-shared into MAX_PIECES ghost regions, which may be aliased
  partition<aliased> p_ghost_nodes = p_nodes_pvs[1].partition(node_neighbor_map);

  CircuitPiece pieces[MAX_PIECES];
  for(i = 0; i #$<$# MAX_PIECES; i++) 
    pieces[i] = { rn_pvt: p_pvt_nodes[i], rn_shr: p_shr_nodes[i],
                  rn_ghost: p_ghost_nodes[i], rw_pvt: p_wires[i] };
  for (t = 0; t #$<$# TIME_STEPS; t++) {
    for (i = 0; i #$<$# MAX_PIECES; i++) calc_new_currents(pieces[i]);
    for (i = 0; i #$<$# MAX_PIECES; i++) distribute_charge(pieces[i], dt);
    for (i = 0; i #$<$# MAX_PIECES; i++) update_voltages(pieces[i]);
  }
}

void calc_new_currents(CircuitPiece piece):
        RWE(piece.rw_pvt), ROE(piece.rn_pvt, piece.rn_shr, piece.rn_ghost) {
  foreach(w : piece.rw_pvt)
    w#$\rightarrow$#current = (w#$\rightarrow$#in_node#$\rightarrow$#voltage - w#$\rightarrow$#out_node#$\rightarrow$#voltage) / w#$\rightarrow$#resistance;
}

void distribute_charge(CircuitPiece piece, float dt):
        ROE(piece.rw_pvt), RdA(piece.rn_pvt, piece.rn_shr, piece.rn_ghost) {
  foreach(w : piece.rw_pvt) {
    w#$\rightarrow$#in_node#$\rightarrow$#new_charge += -dt * w#$\rightarrow$#current;
    w#$\rightarrow$#out_node#$\rightarrow$#new_charge +=  dt * w#$\rightarrow$#current;
  }
}

void update_voltages(CircuitPiece piece): RWE(piece.rn_pvt, piece.rn_shr) {
  foreach(n : piece.rn_pvt, piece.rn_shr) {
    n#$\rightarrow$#voltage += n#$\rightarrow$#new_charge / n#$\rightarrow$#capacitance;
    n#$\rightarrow$#new_charge = 0;
  }
}
\end{lstlisting}

Legion programs organize data into a forest of {\em logical regions}.  Logical
regions express {\em locality} (data that will be used together, and therefore colocated if possible in the same
physical memory) and {\em independence} (disjoint data that may be operated on in parallel).
Researchers have previously explored language designs with hierarchical decomposition of data to express
locality and independence for high performance programming. Two recent examples, Sequoia \cite{Fatahalion06} and 
Deterministic Parallel Java (DPJ) \cite{Bocchino09}, each provide a mechanism to partition the heap recursively
into a tree of collections of data.  The two designs are different in many aspects, but agree that there is
a single tree-shaped partitioning of data that can be checked fully statically (see Section~\ref{sec:related} for more
discussion of related work).

Our own experience with Sequoia and many high-performance applications
written in the current industry standard mix of MPI, shared-memory
threads, and CUDA, has taught us that for many practical situations a
single, fairly static partitioning is insufficient.  In practice, the
best way to partition data is often a function of the data
itself---i.e., the partitions need to be dynamically computed.
Furthermore, it is useful to allow mutliple partitions simultaneously of
the same data, providing different views on to that data. Thus, in Legion the 
handling of regions and partitioning of regions is much more dynamic than in 
previous designs.  In particular,
\begin{itemize}
\item  logical regions are first-class values in Legion
and may be dynamically allocated and stored in data structures;

\item logical regions can be {\em partitioned} into {\em subregions}; the programmer can express arbitrary partitions of
regions;

\item  a logical region may be dynamically partitioned in multiple different ways.
\end{itemize}
A consequence of these decisions is that, through partitioning, a
given datum may belong to multiple different regions.  For example, if
a region $R$ participates in three separate disjoint partition
operations and each partition allocates every element of $R$ to a
subregion (partitions need not be total in Legion), then every element
of $R$ is included in three different subregions.  This is why we use
the term {\em logical} regions: language-level regions serve to name
sets of data but do not imply anything about physical layout.  There
is a separate system of {\em physical regions} at runtime that hold
copies of the data in the language-level logical regions.  In fact,
the Legion implementation routinely maintains multiple distinct
physical regions, each with a copy of the data in the corresponding
logical region, for performance reasons.

A further consequence of placing the same data in multiple logical
regions as a result of runtime computation is that Legion has a very
hard static alias analysis problem on regions, which poses a problem
for parallel computation because knowing regions do not alias is the
basis for safe parallel execution.  This is why languages such as
Sequoia and DPJ allow only a single static partition of each
region---it simplifies static analysis of regions to the point that it
is practical.  

Legion's execution model is that by default, a program's semantics is
its meaning as a sequential program, which we refer to as the {\em
program order} execution; this is similar to DPJ.  While the
implementation is not our focus here, if two functions work on
disjoint data (because all of the regions they use are disjoint), then
Legion may execute them simultaneously.  Also like DPJ,
Legion has a system of {\em permissions} ({\em read}, {\em write}, and
{\em reduce}) on regions and an orthogonal system of region {\em
coherence} modes ({\em excl}, {\em atomic}, and {\em simultaneous})
that increase the number of situations in which functions can be
executed in parallel.

The important difference bewteen Legion and the more static approaches
is that the hardest part of the tests to justify parallel execution is
done dynamically instead of statically.  The key observation is that
alias analysis is hard statically but very easy and relatively cheap
dynamically.  Thus, Legion falls between fully static systems, such as
Sequoia and DPJ, and fully dynamic approaches such as transactional
memory.  Legion still has a significant static component; in
particular, the safety of permissions is checked statically and region
pointer dereferences are checked statically.  The dynamic alias tests
are done at the granularity of regions and one check on a region
itself often serves to prove the safety of many subsequent region
accesses.  In contrast, because transactional memory has no mechanism
for grouping heap data into larger collections, it much test the
overlap between two sets of data on each individual element, which is
much more expensive.


We begin in Section~\ref{sec:example} with an example program that illustrates
a typical style of programming in Legion as well as motivating the need for multiple, dynamically computed  partitions of
a region.  We define Core Legion, a small language suitable for our formal development, in Section~\ref{sec:legioncore}.
The next four sections each state and prove one of our main results and contributions:
\begin{itemize}
\item We prove the soundness of Legion's permissions system (Section~\ref{sec:soundness}).

\item We use the soundness of permissions to prove the soundness of Legion's region coherence modes (Section~\ref{sec:coherence}).

\item We show that if expressions $e_1$ and $e_2$ are {\em non-interfering} (can be executed in parallel), then subexpressions
$e_1'$ of $e_1$ and $e_2'$ of $e_2$ are also non-interfering (Section~\ref{sec:scheduling}).  This result is the basis
for a hierarchical, distributed scheduler in the Legion implementation; on the target class of machines, any centralized
scheduler would be a serious bottleneck.

\item We give experimental evidence for the Legion design.  On three real-world applications, we show that 
dynamic region pointer checks would be expensive, justifying checking this aspect of the type system statically.
We also show that the cost of checking aliasing on region permissions is low, showing that a much more expressive
and dynamic langauge is not incompatible with high performance.

\end{itemize}
Finally, Section~\ref{sec:related} discusses the most closely related work and
Section~\ref{sect:conclusion} concludes.


  










