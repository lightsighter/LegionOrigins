
\section{Introduction}
\label{sec:intro}

In the past decade machine architecture, particularly at the high
performance end of the spectrum, has undergone a revolution.  The
latest supercomputers are now complex hierarchies of many different
kinds of computing technologies: networks of nodes at the top level,
multiple chips per node, mutiple cores within a chip, and, most
recently, multiple accelerators (usually GPUs) per node, which are
themselves can be further decomposed into several levels of machine
hierarchy.  In this paper, we present the operational and static
semantics of Legion, a programming language targeted at providing an
appropriate level of abstraction for programming such machines, one
that is both sufficiently high-level to be portable while still
exposing aspects that are crucial to performance. A very brief summary
of Legion is that data is organized in a hierarchy of {\em regions}
and subregions and computation is organized in a hierarchy of {\em
tasks} and subtasks operating on regions.  Regions and tasks interact
through a static system of {\em region permissions} specifying the
operations a task may perform on a region argument (e.g., read or
write, among others) and novel {\em region coherence} annotations that
expresses whether other tasks may perform operations concurrently on
the region (e.g., {\em exclusive} access for task $t$ guarantees no
other task's updates to a region are visible to $t$).  We prove the
soundness of the permissions and coherence system and use these two
results to prove a third result: if two tasks $t_1$ and $t_2$ are {\em
dependent} (roughly, must be executed in program order to guarantee
the correct answer), then the unique ancestors of $t_1$ and $t_2$ in
the task hierarchy that are {\em siblings} (have the same parent task)
are also dependent.  This theoremis the basis for distributed
scheduling in a Legion implementation, which is crucial for
performance; any centralized scheduler would be a severe bottleneck
because of the huge latencies involved in moving data and computation
in the target class of machines.

Legion programs organize data into {\em logical regions}.  Logical
regions (which we usually refer to simply as {\em regions}) express
{\em locality}, which is just data that will be used together and
therefore should be colocated in the machine.
Listing~\ref{lst:linkedlist} gives an example that defines a region
containing a linked list of integers and a task that sums the elements
of the list.  As is standard in region systems, we use $T @ r$ for the
type of a pointer to a value of type $T$ in region $r$.  The task also
illustrates a simple use of the permissions system; in this case the
task {\tt sum\_list} must have permission {\tt reads(r)}, the ability
to read the values in region {\tt r}.

Listing~\ref{lst:treereverse} gives a more elaborate example.  While
artificial (it is designed to use the greatest number of Legion
features in the smallest space), the program illustrates typical
Legion programming idioms.  Given a list of integers as defined in Listing~\ref{lst:linkedlist}, 
the task {\tt make\_tree} builds a binary tree of pointers to list elements.
Each internal node of the tree stores a pointer to a list element with value $i$
and the left and right subtrees hold pointers to list elements with values less than $i$ and greater than $i$,
respectively.  The task {\tt reverse\_tree} then does an in-place, recursive reversal of the children of each interior
node of the tree.  We focus on a description of the structure of types and permissions in this example.

Line 1 defines a type that is a {\em region relationship} {\tt rr[ rll, rlr, rtl, rtr]}.  Region relationships are
constrained existential types.  The {\tt tree} region relationship defines the type of a node of the tree: it has a pointer
to a list node and two pointers to the left and right subtrees. The crucial part is the {\em subregion} and {\em disjointness}
constraints that describe the relationships between the various regions.  Here {\tt rl} is the region holding all list elements,
{\tt rls} is the region holding



Two of the basic properties programmers need to express in writing
programs for highly parallel, distributed machines are the {\em
locality} and {\em independence} of data. Locality identifies data
that will be used together and so should be placed in the same part of
the machine; independence identifies data sets that are disjoint and
so can be operated on in parallel.  Legion programs use {\em logical
regions} to express both.  A logical region (which we will usually
refer to as simply a {\em region} for brevity) is a
programmer-specified collection of data; we use the notation of
separating conjunction $r_1 \ast r_2$ for disjoint regions $r_1$ and
$r_2$.



%Programming
%these machines is currently done by using a heterogeneous collection
%of software technologies targeted at the individual level; a typical
%melange is MPI for the network, OpenMP for the node, and CUDA for the GPUs.



% This is a description of how the listings should be formatted.
% It can go anywhere before the listings.
\lstset{
  captionpos=b,
  language=Haskell,
  basicstyle=\scriptsize,
  numbers=left,
  numberstyle=\tiny,
  columns=fullflexible,
  stepnumber=1,
  escapechar=\#,
  keepspaces=true,
  literate={<}{{$\langle$}}1 {>}{{$\rangle$}}1,
  morekeywords={task,rr,int,bool,isnull,partition,as,downregion,upregion,reads,writes,rdwrs,reduces,read,write,reduce,using,unpack,pack,coloring,color,newcolor,atomic,simultaneous},
  deletekeywords={float,head,min,max}
}

% The linked list example
% Add float={t} to the list of options if you want the listing at the top
\begin{lstlisting}[label={lst:linkedlist},caption={Linked List Example}]
type list<r> = < int, list<r>@r >

task sum_list[r] ( l:list<r>@r ), reads(r) : int =
    if isnull(l) then 0 else
    let v : list<r> = read(l) in
        v.1 + sum_list[r](v.2)
\end{lstlisting}

% The tree example with partitioning and tree reversal
\begin{lstlisting}[float={t},label={lst:treereverse},caption={Tree Partitioning and Reversal Example}]
type tree<rl,rls,rt> = rr[rll, rlr, rtl, rtr] 
                       < list<rl>@rls, < tree<rl,rll,rtl>@rtl, tree<rl,rlr,rtr>@rtr > >
     		       where rll #$\le$# rls and rlr #$\le$# rls and rll #$*$# rlr and 
                                  rtl #$\le$# rt and rtr #$\le$# rt  and rtl #$*$# rtr

task color_list[r,rs] ( clr: coloring(rs), head: list<r>@r, 
                        splitval: int ), reads(r) : coloring(rs) =
    if isnull(head) then clr else
    let v : list<r> = read(head) in
    let ps : list<r>@rs = downregion(head, rs) in
        color_list[r,rs](if isnull(ps) then clr 
                                else color(clr, ps, if v.1 #$<$# splitval then 1 else 2), v.2, splitval)

task make_tree[rl,rls,rt] ( l: list<rl>@rl, min: int, 
                            max: int), reads(rl,rt), writes(rt) : tree<rl,rls,rt>@rt =
    if isnull(l) then null tree<rl,rls,rt>@rt else 
    let v : list<rl> = read(l) in
    if (v.1 #$<$# min) | (v.1 #$>$# max) then
    make_tree[rl,rls,rt](v.2, min, max) else
    let root : tree<rl,rls,rt>@rt = new tree<rl,rls,rt>@rt in
    partition rt using newcolor rt as rtl,rtr in
    partition rls using color_list[rl,rls](newcolor rls, v.2, v.1) as rll,rlr in
    let ptr : list<rl>@rls = downregion(l, rls) in
    let lhs : tree<rl,rll,rtl>@rtl = make_tree[rl,rll,rtl](v.2, min, v.1) in
    let rhs : tree<rl,rlr,rtr>@rtr = make_tree[rl,rlr,rtr](v.2, v.1, max) in
    let v2 : tree<rl,rls,rt> = pack < ptr, < lhs, rhs > > as tree<rl,rls,rt>[rll, rlr, rtl, rtr] in
        write(root, v2)

task reverse_tree[rl,rls,rt] ( root: tree<rl,rls,rt>@rt ), reads(rt), writes(rt) : tree<rl,rls,rt>@rt =
     if isnull(root) then null tree<rl,rls,rt>@rt else
     let v : tree<rl,rls,rt> = read(root) in
     unpack v as u : tree<rl,rls,t>[rll, rlr, rtl, rtr] in
     let lhs_r : tree<rl,rll,rtl>@rtl = reverse_tree[rl,rll,rtl](u.2.1) in
     let rhs_r : tree<rl,rlr,rtr>@rtr = reverse_tree[rl,rlr,rtr](u.2.2) in
     let v_r : tree<rl,rls,rt> = pack < u.1, < rhs_r, lhs_r > > as tree<rl,rls,rt>[rlr, rll, rtr, rtl] in
        write(root, v_r)
\end{lstlisting}

\begin{lstlisting}[label={lst:histogram},caption={Histogram with Reductions and Atomic Coherence}]
type hist = < int, int >

task hist_tree1[rl,rls,rt,rh] ( root: tree<rl,rls,rt>@rt, hptr: hist@rh, 
                                t : int ), reads(rt,rls,rh), writes(rh), atomic(rh) : int =
    if isnull(root) then 0 else
    let v : tree<rl,rls,rt> = read(root) in
    unpack v as u : tree<rl,rls,t>[rll, rlr, rtl, rtr] in
    let lval : list<rl> = read(u.1) in
    let hval : hist = read(hptr) in
    let hval2 : hist = if lval.1 #$<$# t then < hval.1 + 1, hval.2 >
                                     else < hval.1, hval.2 + 1 > in
    let _ : hist@rh = write(hptr, hval2) in
        1 + hist_tree1[rl,rll,rtl,rh](u.2.1, hptr, t) + hist_tree1[rl,rlr,rtr,rh](u.2.2, hptr, t)

task inc_bucket ( hval: hist, b: int ) : hist =
    if b #$<$# 2 then < hval.1 + 1, hval.2 > else < hval.1, hval.2 + 1 >

task hist_tree2[rl,rls,rt,rh] ( root: tree<rl,rls,rt>@rt, hptr: hist@rh, 
                                t : int ), reads(rt,rls), reduces(inc_bucket, rh) : int =
    if isnull(root) then 0 else
    let v : tree<rl,rls,rt> = read(root) in
    unpack v as u : tree<rl,rls,t>[rll, rlr, rtl, rtr] in
    let lval : list<rl> = read(u.1) in
    let _ : hist@rh = reduce(inc_bucket, hptr, if lval.1 #$<$# t then 1 else 2) in
        1 + hist_tree1[rl,rll,rtl,rh](u.2.1, hptr, t) + hist_tree1[rl,rlr,rtr,rh](u.2.2, hptr, t)
\end{lstlisting}
