We'd first like to thank the reviewers for their detailed and useful feedback.
Rather than addressing each reviewer's questions separately, we have organized
our response based on the areas the questions covered.

First, there were multiple requests for more detail on the code example, the
use of colorings to describe partitions, and the algorithm used to perform 
efficient dynamic disjointness checks.  Each of these was covered in significant
detail in [1], which may have been unavailable to the reviewers previously but can
now be found at http://theory.stanford.edu/~aiken/publications/papers/sc12.pdf .

As described in [1], Legion does not attempt to solve the (in many cases still-open)
problem of partitioning data for any given application.  The body of the "color_circuit"
task would likely consist of a call to an external library (e.g. PARMETIS for graph-based
data structures).  The coloring is merely a way to capture the result of that external
computation for use by the Legion runtime.  The "build_lists" task is not strictly required.
While a task could iterate over the elements of a subregion through repeated uses of "downregion" on
each element of the parent region, by building a list up front, the cost of those "downregion"
checks can be amortized over multiple iterations of the simulation.

In Core Legion, colorings are explicit mappings of region elements (named by their location)
to integer "colors".  This represents the most general case of describing the partitioning of
a region.  More concise descriptions exist in the full Legion language (e.g. using a pure
function to determine the color of an element on demand), but a single form was selected for
Core Legion for simplicity.

[Legion supports the "partition then allocate" model in which new elements allocated in a subregion
are guaranteed to exist in parent regions as well and preserve that subregion's disjointness with
any other regions.  The use of a non-empty initial coloring in the operational semantics simplifies
this in Core Legion by allowing extra unnamed locations to exist in every region to allow these
allocations without changing the sets of locations assigned to physical regions.  {Is this opening a
can of worms?}]

As several reviewers noted, the Legion type system is similar in many ways to existing region-based
typed systems; this is by design.  Additions to the "standard" region-based type system were 
done to capture the new features of Legion: colorings as a description of an arbitrary partitioning
of a region, a hierarchy of regions in which a location may be contained in multiple regions, the 
ability to capture the relationship between regions, and the ability to relax the determinism of 
execution via coherence modes.  With these additional features a proof that soundness was preserved 
was a prerequisite for later proofs in our paper.

A description of the usage and intuition behind coherence modes was fully presented in [1] and
was omitted from this paper due to space constraints.
"Exclusive" coherence corresponds to apparently-sequential execution, "atomic" corresponds 
to transactional-memory-like execution, and "simultaneous" corresponds to
"all bets are off" pthreads-style parallelism.  However, unlike other implementations, coherence modes 
only allow for reordering of subtasks with the same parent task, permitting the containment of non-determinism
to a portion of the task hierarchy.  This paper contains two new
results about coherence modes not contained in [1].  First, we give a formal semantics of the possible
interleavings allowed by 
different coherence modes and their interactions.  Second, we prove that coherence modes do not
impact the soundness of our type system or the correctness of our hierarchical scheduling algorithm.

Finally, the choice of large-step operational semantics was made to match the hierachical and distributed
scheduling used by the Legion runtime.  When coherence modes other than exclusive are used, there may be
multiple tasks modifying the same location of memory - the clobber set is the set of all such locations for
a given task.  The clobber set is used to bound the allowed non-determinism within a given task, and the
fact that the top-level task (which has no sibling tasks) has an empty clobber set guarantees that any 
execution of the program is consistent with a standard sequentially consistent memory model.

An advantage of the large-step semantics with the use of clobber sets is that our soundness result holds for
any scheduling of tasks that satisfies the "valid_interleave" rules.  We considered the use of small-step semantics
that explicitly track the state of every parallel task's execution, but the complexity of the constraints used
to decide which task(s) were able to take a step at any given point were onerous and would limit our soundness
guarantees to only that scheduling algorithm.
