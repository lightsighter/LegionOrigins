
\section{Related Work}
\label{sec:related}
Regions have been used for many purposes in the type system literature.  We
cover the ones most closely related to the Legion type system.

Deterministic Parallel Java (DPJ) is the only other region system that we are
aware of that uses regions for extracting parallelism from a 
program to improve performance \cite{Bocchino09}.  There are several
differences between DPJ and Legion.  First, regions in Legion are first-class 
which allows them to be created, deleted, partitioned, packed, and unpacked 
dynamically.  This allows programmers to dynamically determine partitioning
schemes and allocation strategies based on program data at runtime unlike DPJ
where partition schemes must be decided at compile-time.  Despite the dynamic nature
of Legion where regions can be packed and unpacked, we still maintain disjointness
information through constraints on region relationships.  Legion also allows 
programmers to create multiple partitions of the same region to give different 
views onto the same data which is not possible in DPJ.  DPJ only supports the 
equivalent to Legion's exclusive and atomic coherence modes \cite{Bocchino11} 
while Legion provides safe execution even in simultaneous environments.  The 
implementation of DPJ only runs on shared memory machines, while Legion's runtime
uses its knowledge of dynamic regions to run on distributed heterogenous machines.

% Unclear to me what subtleties need to be pointed out here and explained
% to properly differentiate our work
There have been many region systems that use regions for memory management either
to prove safety properties or for performance.  Tofte and Talpin introduced the
first region type system for memory management\cite{Tofte94}.  Aiken et. al. 
improved this system to decouple region allocation from lexical scoping\cite{Aiken95}.
Henglein et. al. introduced a type system for reasoning about memory management
in imperative object-oriented languages \cite{Henglein01}.  Walker et. al. add
capablities to regions to give provable safety guarantees about how regions
can be manipulated \cite{Walker00}.  

In addition to region languages with static type systems, there have been several
dynamic region languages.  Cyclone used both a static type system and dynamic
region checks to enforce memory safety properties of C programs\cite{Grossman02}.
Gay and Aiken introduced RC which reference counts regions dynamically and uses
a static type system to reason about effeciently garbage collecting regions\cite{Gay01}.

% I'm also not sure how much detail to go into here.  DPJ spends a lot of time
% on these papers, but I'm not sure I understand all the details of these papers.
% DPJ also cites Lu06 here, but I'm not sure if we have to
Type and effect systems have also been used to reason about regions.  FX presented
the original type and effect system on regions \cite{Lucassen88}, but was restricted 
to using a finite number of regions and was incapable of describing nested data
structures.  There have been many type and effect systems for ownership types
\cite{Boyapati03} including ones that leverage nested regions for describing
relationships \cite{Clarke02,Cameron07}.  However, ownership type and effect systems
are primarily used for reasoning about determinism in object oriented languages and
don't capture the range of disjointness properties that can be specified in Legion.
% Do we need to enumerate what these disjointness properties are (DPJ does)
Type and effect systems have also been used in the context of parallelism to discover
deadlocks and race conditions \cite{Boyapati02,Abadi06,Jacobs08}, but do not present 
any mechanism for discovering parallelism.

Separation Logic is another mechanism that can be used for reasoning about disjointness
of program data \cite{Reynolds02}.  Concurrent separation logic\cite{Brookes04} has been 
used both to parallelize sequential programs\cite{Raza09,Gotsman07} and to provide 
a mechanism for reasoning about independence\cite{Hayman06}.
While we adopted some notation from separation logic, we ultimately chose to use a 
type and effect system as our primary formalism because separation logic cannot easily 
describe the interleaving of effects to non-disjoint regions of memory.
%Still not sure what we want to put here.
% DPJ sites additional separation logic papers but they didn't seem very similar.
% Let me know if you think we should include them as well.

Chapel \cite{Chamberlain:Chapel} and X10 \cite{X1005} are similar parallel programming
models to Legion.  Chapel's domains and X10's places provide the programmer with a 
mechanism for expressing locality similar to regions in Legion.  However, domains
and places are not used in any way for independence analysis for discovering parallelism.
Jade is a parallel programming mode that relies on programmer annotations to describe
data disjointness\cite{Rinard98}.  Jade then leverages this disjointness information
to implicitly discover parallelism similar to Legion.
