\newcommand{\oton}[1]{{#1}_1,\ldots,{#1}_n}
\newcommand{\otok}[2]{{#2}_1,\ldots,{#2}_{#1}}

\begin{table*}
\centering
{\small
\begin{tabular}{cclr}

$T$ & ::= &  & types \\
  &$\mid$& bool $\;\;\;\mid\;\;\;$ int & base types \\
  &$\mid$& $\langle T_1, T_2 \rangle$ & tuple \\
  &$\mid$& $T@(\oton{r})$ & pointer \\
  &$\mid$& $\text{coloring}(r)$ & region coloring \\
  &$\mid$& $\exists \oton{r}. T\text{ where }R$ & region relationship \\
  &$\mid$& $\forall \oton{r}. (\oton{T}), \Phi \rightarrow T_r$ & functions \\
\\
$R$ & ::= & true & region constraints \\
  &$\mid$& $r_1 \leq r_2$ & subregion \\
  &$\mid$& $r_1 * r_2$ & disjointness \\
  &$\mid$& $R_1 \wedge R_2$ & conjunction \\
\\
$\Phi$ & ::= & $\{ \oton{\phi} \}$ & privileges \\
$\phi$ & ::= & reads$(r)$ $\;\;\;\mid\;\;\;$ writes$(r)$ $\;\;\;\mid\;\;\;$ reduces$(id,r)$ & \\
\\
$v$ & ::= & & values \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & base values \\
  &$\mid$& $\langle v_1, v_2 \rangle$ & tuple \\
  &$\mid$& null $\;\;\;\mid\;\;\;$ $a$ & address \\
  &$\mid$& $\{ (a_i, iv), \ldots \}$ & coloring \\
  &$\mid$& $\langle \langle \oton{\rho}, v\rangle \rangle$ & region relationship instance \\
\\
$bv$ & ::= & false $\;\;\;\mid\;\;\;$ true \\
\\
$iv$ & ::= & 0 $\;\;\;\mid\;\;\;$ 1 $\ldots$ \\
\\
$e$ & ::= & & expressions \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & constants \\
  &$\mid$& $\langle e_1, e_2 \rangle$ $\;\;\;\mid\;\;\;$ $e$.1 $\;\;\;\mid\;\;\;$ $e$.2 & tuple \\
  &$\mid$& $id$ &  \\
  &$\mid$& $\text{new}\ T@r$ $\;\;\;\mid\;\;\;$ $\text{null }T@r$ $\;\;\;\mid\;\;\;$ $\text{isnull}(e)$ & \\
  &$\mid$& $\text{upregion}(e, r_1,\ldots,r_n)$ $\;\;\;\mid\;\;\;$ $\text{downregion}(e, r_1,\ldots,r_n)$ & \\
  &$\mid$& $\text{read}(e_1)$ $\;\;\;\mid\;\;\;$ $\text{write}(e_1, e_2)$ $\;\;\;\mid\;\;\;$ $\text{reduce}(id, e_1, e_2)$ & memory access \\
  &$\mid$& $\text{newcolor}\ r$ $\;\;\;\mid\;\;\;$ $\text{color}(e_1, e_2, e_3)$ & coloring operations \\
  &$\mid$& $e_1 + e_2$ & integer operations \\
  &$\mid$& $e_1 < e_2$ & comparison operations \\
  &$\mid$& $\text{let}\ id : T = e_1 \text{in}\ e_2$ &  \\
  &$\mid$& $\text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3$ &  \\
  &$\mid$& $id[r_1, \ldots, r_n](e_1,\ldots,e_n)$ & task calls \\
  &$\mid$& $\text{partition}\ r_p\text{ using }e_1\text{ as }\oton{r}\text{ in }\ e_2$ &  \\
  &$\mid$& $\text{pack}\ e_1\ \text{as}\ T[r_1,\ldots,r_n]$ &  \\
  &$\mid$& $\text{unpack}\ e_1\ \text{as}\ id : T[r_1,\ldots,r_n]\ \text{in}\ e_2$ &  \\

\end{tabular}
}
\caption{Types}
\end{table*}

%\newcommand{\infrule}[2]{\displaystyle\frac{\displaystyle\strut{#1}}{\displaystyle\strut {#2}}}
\newcommand{\cinfrule}[3]{\parbox{14cm}{\hfil$\infrule{#1}{#2}$\hfil}\parbox{4cm}{$\,#3$\hfil}}
\newcommand{\finfrule}[2]{\vspace{10pt}\framebox{$\infrule{#1}{#2}$}\vspace{10pt}}

\newcommand{\infx}[2]{\infrule{\begin{array}{l}{#1}\end{array}}{#2}}

\newcommand{\regionexpand}[0]{[r'_1/r_1, \ldots, r'_n/r_n]}
\newcommand{\rtriple}[3]{\left({#1},{#2},{#3}\right)}
\newcommand{\rsingle}[1]{\rtriple{#1}{\emptyset}{\top}}
\newcommand{\rtripsub}[3]{\rtriple{#1}{\Phi_{#2}}{C_{#3}}}
\newcommand{\envsub}[2]{\Gamma, \Phi_{#1}, C_{#2} \vdash}
\newcommand{\typeenv}[0]{\Gamma, \Phi, R \vdash}

\pagebreak

Type rules:

\framebox{
$
\begin{array}{c}
\typeenv bv : bool \\
\typeenv iv : int \\

\end{array}
$
}

\finfrule{\typeenv e : \langle T_1,T_2 \rangle}{\typeenv e\text{.1}\ : T_1} \hspace{1cm}
\finfrule{\typeenv e : \langle T_1,T_2 \rangle}{\typeenv e\text{.2}\ : T_2} \\

\finfrule{\Gamma(id) = T}{\typeenv id : T} \\

\framebox{$\typeenv \text{null }T@r : T@r$} \hspace{1cm}
\framebox{$\typeenv \text{new }T@r : T@r$} \\

\finfrule{\typeenv e : T@(\oton{r})}{\typeenv \text{isnull}(e) : bool} \\

\finfrule{\begin{array}{l}\typeenv e : T@(\otok{k}{r'}) \\ R \models \bigwedge_{i \in [1,k]}\bigvee_{j \in [1,n]} r'_i \leq r_j\end{array}}{\typeenv upregion(e,\oton{r}) : T@(\oton{r})} \\

\finfrule{\begin{array}{l}\typeenv e : T@(\otok{k}{r'}) \\ R \models \bigwedge_{j \in [1,n]}\bigvee_{i \in [1,k]} r_j \leq r'_i\end{array}}{\typeenv downregion(e,\oton{r}) : T@(\oton{r})} \\

\finfrule{\begin{array}{l}\typeenv e_1 : T@(\oton{r}) \\ \forall i, reads(r_i) \in \Phi\end{array}}{\typeenv \text{read}(e_1) : T} \\

\finfrule{\begin{array}{l}\typeenv e_1 : T@(\oton{r}) \\ \typeenv e_2 : T \\ \forall i, writes(r_i) \in \Phi\end{array}}{\typeenv \text{write}(e_1, e_2) : bool} \\

\finfrule{\begin{array}{l}
\Gamma(id) = (T_1, T_2), \emptyset \rightarrow T_1 \\
\typeenv e_1 : T_1@(\oton{r}) \\
\typeenv e_2 : T_2 \\
\forall i, (reduces(id, r_i) \in \Phi) \vee ((reads(r_i) \in \Phi) \wedge (writes(r_i) \in \Phi))\end{array}}{\typeenv \text{reduce}(id, e_1, e_2) : bool} \\

\framebox{$\typeenv \text{newcolor }r : \text{coloring}(r)$} \\

\finfrule{\begin{array}{l}
\typeenv e_1 : \text{coloring}(r) \\
\typeenv e_2 : T@r \\
\typeenv e_3 : int
\end{array}}
{\typeenv \text{color}(e_1, e_2, e_3) : \text{coloring}(r)} \\

\finfrule{\begin{array}{l}\typeenv e_1 : int \\ \typeenv e_2 : int\end{array}}{\typeenv e_1 + e_2 : int} \hspace{1 cm}
\finfrule{\begin{array}{l}\typeenv e_1 : int \\ \typeenv e_2 : int\end{array}}{\typeenv e_1 < e_2 : bool} \\

\finfrule{\begin{array}{l}\typeenv e_1 : T_1 \\ \Gamma' = \Gamma[id/T_1] \\ \Gamma', \Phi, R \vdash e_2 : T_2 \end{array}}{\typeenv : \text{let}\ id : T_1 \text{in}\ e_2 : T_2} \\

\finfrule{\begin{array}{l}\typeenv e_1 : bool \\ \typeenv e_2 : T \\ \typeenv e_3 : T\end{array}}{\typeenv \text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3 : T} \\

\finfrule{
\begin{array}{l}
\Gamma(id) = \forall \otok{k}{r'}.(\oton{T}),\Phi_i \rightarrow T_r \\
\typeenv e_i : T_i[r_1/r'_1,\ldots,r_k/r'_k] \\
\Phi_i[r_1/r'_1,\ldots,r_k/r'_k] \subseteq \Phi
\end{array}}
{\typeenv id[\otok{k}{r}](\oton{e}) : T_r[r_1/r'_1,\ldots,r_k/r'_k]} \\

\finfrule{
\begin{array}{l}
\typeenv e_1 : \text{coloring}(r_p) \\
R' = R \wedge \bigwedge_{i \in [1,k]} r_i \leq r_p \wedge \bigwedge_{i \not= j} r_i * r_j \\
\Gamma, \Phi, R' \vdash e_2 : T
\end{array}}
{\typeenv \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 : T} \\

\finfrule{
\begin{array}{l}
T_1 = \exists \otok{k}{r'}. T_2\text{ where }R_1 \\
R \models R_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\typeenv e_1 : T_2[r_1/r'_1,\ldots,r_k/r'_k]
\end{array}}
{\typeenv \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] : T_1} \\

\finfrule{
\begin{array}{l}
T_1 = \exists \otok{k}{r'}. T_2\text{ where }R_1 \\
\typeenv e_1 : T_1 \\
\Gamma' = \Gamma[T_2[r_1/r'_1,\ldots,r_k/r'_k] / id] \\
R' = R \wedge R_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\Gamma', \Phi, R' \vdash e_2 : T_3
\end{array}}
{\typeenv \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 : T_3} \\

