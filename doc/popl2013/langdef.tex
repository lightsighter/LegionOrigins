\newcommand{\oton}[1]{{#1}_1,\ldots,{#1}_n}
\newcommand{\otok}[2]{{#2}_1,\ldots,{#2}_{#1}}

\begin{table*}
\centering
{\small
\begin{tabular}{cclr}

$T$ & ::= &  & types \\
  &$\mid$& bool $\;\;\;\mid\;\;\;$ int & base types \\
  &$\mid$& $\langle T_1, T_2 \rangle$ & tuple \\
  &$\mid$& $T@(\oton{r})$ & pointer \\
  &$\mid$& $\text{coloring}(r)$ & region coloring \\
  &$\mid$& $\exists \oton{r}. T\text{ where }\Omega$ & region relationship \\
  &$\mid$& $\forall \oton{r}. (\oton{T}), \Phi \rightarrow T_r$ & functions \\
\\
$\Omega$ & ::= & $\{ \oton{\omega} \}$ & region constraints \\
$\omega$ & ::= & $r_1 \leq r_2$ & subregion \\
  &$\mid$& $r_1 * r_2$ & disjointness \\
\\
$\Phi$ & ::= & $\{ \oton{\phi} \}$ & privileges \\
$\phi$ & ::= & reads$(r)$ $\;\;\;\mid\;\;\;$ writes$(r)$ $\;\;\;\mid\;\;\;$ reduces$(id,r)$ & \\
\\
$v$ & ::= & & values \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & base values \\
  &$\mid$& $\langle v_1, v_2 \rangle$ & tuple \\
  &$\mid$& null $\;\;\;\mid\;\;\;$ $a$ & address \\
  &$\mid$& $\{ (a_i, iv), \ldots \}$ & coloring \\
  &$\mid$& $\langle \langle \oton{\rho}, v\rangle \rangle$ & region relationship instance \\
\\
$bv$ & ::= & false $\;\;\;\mid\;\;\;$ true \\
\\
$iv$ & ::= & 0 $\;\;\;\mid\;\;\;$ 1 $\ldots$ \\
\\
$e$ & ::= & & expressions \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & constants \\
  &$\mid$& $\langle e_1, e_2 \rangle$ $\;\;\;\mid\;\;\;$ $e$.1 $\;\;\;\mid\;\;\;$ $e$.2 & tuple \\
  &$\mid$& $id$ &  \\
  &$\mid$& $\text{new}\ T@r$ $\;\;\;\mid\;\;\;$ $\text{null }T@r$ $\;\;\;\mid\;\;\;$ $\text{isnull}(e)$ & \\
  &$\mid$& $\text{upregion}(e, r_1,\ldots,r_n)$ $\;\;\;\mid\;\;\;$ $\text{downregion}(e, r_1,\ldots,r_n)$ & \\
  &$\mid$& $\text{read}(e_1)$ $\;\;\;\mid\;\;\;$ $\text{write}(e_1, e_2)$ $\;\;\;\mid\;\;\;$ $\text{reduce}(id, e_1, e_2)$ & memory access \\
  &$\mid$& $\text{newcolor}\ r$ $\;\;\;\mid\;\;\;$ $\text{color}(e_1, e_2, e_3)$ & coloring operations \\
  &$\mid$& $e_1 + e_2$ & integer operations \\
  &$\mid$& $e_1 < e_2$ & comparison operations \\
  &$\mid$& $\text{let}\ id : T = e_1 \text{in}\ e_2$ &  \\
  &$\mid$& $\text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3$ &  \\
  &$\mid$& $id[r_1, \ldots, r_n](e_1,\ldots,e_n)$ & task calls \\
  &$\mid$& $\text{partition}\ r_p\text{ using }e_1\text{ as }\oton{r}\text{ in }\ e_2$ &  \\
  &$\mid$& $\text{pack}\ e_1\ \text{as}\ T[r_1,\ldots,r_n]$ &  \\
  &$\mid$& $\text{unpack}\ e_1\ \text{as}\ id : T[r_1,\ldots,r_n]\ \text{in}\ e_2$ &  \\

\end{tabular}
}
\caption{Types}
\end{table*}

%\newcommand{\infrule}[2]{\displaystyle\frac{\displaystyle\strut{#1}}{\displaystyle\strut {#2}}}
\newcommand{\cinfrule}[3]{\parbox{14cm}{\hfil$\infrule{#1}{#2}$\hfil}\parbox{4cm}{$\,#3$\hfil}}
\newcommand{\finfrule}[2]{\vspace{10pt}\framebox{$\infrule{#1}{#2}$}\vspace{10pt}}

\newcommand{\infx}[2]{\infrule{\begin{array}{l}{#1}\end{array}}{#2}}

\newcommand{\regionexpand}[0]{[r'_1/r_1, \ldots, r'_n/r_n]}
\newcommand{\rtriple}[3]{\left({#1},{#2},{#3}\right)}
\newcommand{\rsingle}[1]{\rtriple{#1}{\emptyset}{\top}}
\newcommand{\rtripsub}[3]{\rtriple{#1}{\Phi_{#2}}{C_{#3}}}
\newcommand{\envsub}[2]{\Gamma, \Phi_{#1}, C_{#2} \vdash}
\newcommand{\typeenv}[0]{\Gamma, \Phi, \Omega \vdash}

\pagebreak

Type rules:

\framebox{$\typeenv bv : bool$} \hspace{1cm}
\framebox{$\typeenv iv : int$} \\

\finfrule{\typeenv e : \langle T_1,T_2 \rangle}{\typeenv e\text{.1}\ : T_1} \hspace{1cm}
\finfrule{\typeenv e : \langle T_1,T_2 \rangle}{\typeenv e\text{.2}\ : T_2} \\

\finfrule{\Gamma(id) = T}{\typeenv id : T} \\

\framebox{$\typeenv \text{null }T@r : T@r$} \hspace{1cm}
\framebox{$\typeenv \text{new }T@r : T@r$} \\

\finfrule{\typeenv e : T@(\oton{r})}{\typeenv \text{isnull}(e) : bool} \\

\finfrule
{\begin{array}{l}
\typeenv e : T@(\otok{k}{r'}) \\
\forall i. \exists j, r'_i \leq r_j \in \Omega^* \\
\end{array}}
{\typeenv upregion(e,\oton{r}) : T@(\oton{r})} \\

\finfrule
{\begin{array}{l}
\typeenv e : T@(\otok{k}{r'}) \\
\forall j. \exists i, r_j \leq r'_i \in \Omega^* \\
\end{array}}
{\typeenv downregion(e,\oton{r}) : T@(\oton{r})} \\

\finfrule
{\begin{array}{l}
\typeenv e_1 : T@(\oton{r}) \\
\forall i, reads(r_i) \in \Phi^*\end{array}}
{\typeenv \text{read}(e_1) : T} \\

\finfrule
{\begin{array}{l}
\typeenv e_1 : T@(\oton{r}) \\
\typeenv e_2 : T \\
\forall i, writes(r_i) \in \Phi^*
\end{array}}
{\typeenv \text{write}(e_1, e_2) : bool} \\

\finfrule
{\begin{array}{l}
\Gamma(id) = (T_1, T_2), \emptyset \rightarrow T_1 \\
\typeenv e_1 : T_1@(\oton{r}) \\
\typeenv e_2 : T_2 \\
\forall i, reduces(id, r_i) \in \Phi^*
\end{array}}
{\typeenv \text{reduce}(id, e_1, e_2) : bool} \\

\framebox{$\typeenv \text{newcolor }r : \text{coloring}(r)$} \\

\finfrule{\begin{array}{l}
\typeenv e_1 : \text{coloring}(r) \\
\typeenv e_2 : T@r \\
\typeenv e_3 : int
\end{array}}
{\typeenv \text{color}(e_1, e_2, e_3) : \text{coloring}(r)} \\

\finfrule{\begin{array}{l}\typeenv e_1 : int \\ \typeenv e_2 : int\end{array}}{\typeenv e_1 + e_2 : int} \hspace{1 cm}
\finfrule{\begin{array}{l}\typeenv e_1 : int \\ \typeenv e_2 : int\end{array}}{\typeenv e_1 < e_2 : bool} \\

\finfrule{\begin{array}{l}\typeenv e_1 : T_1 \\ \Gamma' = \Gamma[id/T_1] \\ \Gamma', \Phi, \Omega \vdash e_2 : T_2 \end{array}}{\typeenv : \text{let}\ id : T_1 \text{in}\ e_2 : T_2} \\

\finfrule{\begin{array}{l}\typeenv e_1 : bool \\ \typeenv e_2 : T \\ \typeenv e_3 : T\end{array}}{\typeenv \text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3 : T} \\

\finfrule{
\begin{array}{l}
\Gamma(id) = \forall \otok{k}{r'}.(\oton{T}),\Phi_i \rightarrow T_r \\
\typeenv e_i : T_i[r_1/r'_1,\ldots,r_k/r'_k] \\
\Phi_i[r_1/r'_1,\ldots,r_k/r'_k] \subseteq \Phi^*
\end{array}}
{\typeenv id[\otok{k}{r}](\oton{e}) : T_r[r_1/r'_1,\ldots,r_k/r'_k]} \\

\finfrule{
\begin{array}{l}
\typeenv e_1 : \text{coloring}(r_p) \\
\Omega' = \Omega \wedge \bigwedge_{i \in [1,k]} r_i \leq r_p \wedge \bigwedge_{i \not= j} r_i * r_j \\
\Gamma, \Phi, \Omega' \vdash e_2 : T
\end{array}}
{\typeenv \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 : T} \\

\finfrule{
\begin{array}{l}
T_1 = \exists \otok{k}{r'}. T_2\text{ where }\Omega_1 \\
\Omega \models \Omega_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\typeenv e_1 : T_2[r_1/r'_1,\ldots,r_k/r'_k]
\end{array}}
{\typeenv \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] : T_1} \\

\finfrule{
\begin{array}{l}
T_1 = \exists \otok{k}{r'}. T_2\text{ where }\Omega_1 \\
\typeenv e_1 : T_1 \\
\Gamma' = \Gamma[T_2[r_1/r'_1,\ldots,r_k/r'_k] / id] \\
\Omega' = \Omega \wedge \Omega_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\Gamma', \Phi, \Omega' \vdash e_2 : T_3
\end{array}}
{\typeenv \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 : T_3} \\

\subsection{Closure of region constraints and priviledges}

\framebox{
$\begin{array}{l}
\Omega \subseteq \Omega^* \\
r_i \leq r_j \in \Omega^*  \Rightarrow r_i \leq r_i \in \Omega^*\wedge r_j \leq r_j \in \Omega^* \\
r_i \leq r_j \in \Omega^* \wedge r_j \leq r_k \in \Omega^* \Rightarrow r_i \leq r_k \in \Omega^* \\
r_i \leq r_j \in \Omega^* \wedge r_j * r_k \in \Omega^* \Rightarrow r_i * r_k \in \Omega^* \\
r_i * r_j \in \Omega^* \Rightarrow r_j * r_i \in \Omega^* \\
\end{array}$
} \\
\framebox{
$\begin{array}{l}
\Phi \subseteq \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge reads(r_j) \in \Phi^* \Rightarrow reads(r_i) \in \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge writes(r_j) \in \Phi^* \Rightarrow writes(r_i) \in \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge reduces(id, r_j) \in \Phi^* \Rightarrow reduces(id, r_i) \in \Phi^* \\
reads(r) \in \Phi^* \wedge writes(r) \in \Phi^* \wedge \\
\hspace{1cm} \Gamma(id) = \forall \otok{k}{r}. (\oton{T}), E \rightarrow T_r \Rightarrow reduces(id, r) \in \Phi^*
\end{array}$
}

\subsection{Operational Semantics}

Operational semantics rules have the following form: \\

\newcommand{\opsenv}{M, L, H, S, C \vdash}
\newcommand{\opsenvm}[1]{{#1}, L, H, S, C \vdash}
\newcommand{\opsenvs}[1]{M, L, H, {#1}, C \vdash}
\newcommand{\opsenvls}[2]{M, {#1}, H, {#2}, C \vdash}
\newcommand{\opsenvms}[2]{{#1}, L, H, {#2}, C \vdash}
\newcommand{\opsenvmls}[3]{{#1}, {#2}, H, {#3}, C \vdash}

\framebox{$\opsenv e \mapsto v, S', E$}

where: 
\begin{itemize}
\item $M$ is the mapping from logical regions $r_i$ in types to physical regions $\rho_i$, which are sets of memory locations
\item $L$ is the mapping of local variable names to their values
\item $H$ is the heap typing, mapping from memory locations to types
\item $S$ is the store, mapping from memory locations $l_i$ to values
\item $C$ is the ``clobber set'', a set of memory locations that may be accessed by concurrently executing operations (??? does this need to be split into read/write/reduce?)
\item $e$ is the expression being evaluated
\item $v$ is the result of the evaluation
\item $E$ is a memory trace (i.e. the effects) of the execution, a list of read/write/reduce operations in the order they were performed
\end{itemize}

\framebox{$\opsenv bv \mapsto bv, []$} \hspace{1cm}
\framebox{$\opsenv iv \mapsto iv, []$} \\

\finfrule
{\opsenv e \mapsto \langle v_1, v_2 \rangle, E}
{\opsenv e\text{.1} \mapsto v_1, E} \hspace{1cm}
\finfrule
{\opsenv e \mapsto \langle v_1, v_2 \rangle, E}
{\opsenv e\text{.2} \mapsto v_2, E} \\

\finfrule
{L(id) = v}
{\opsenv id \mapsto v, []} \\

\framebox{$\opsenv \text{null }T@r \mapsto null, []$} \\

\finfrule
{\begin{array}{l}
l \in M(r) \\
H(l) = T[M]
\end{array}}
{\opsenv \text{new }T@r \mapsto l, []} \\

\finfrule
{\opsenv e \mapsto v, E}
{\opsenv \text{isnull}(e) \mapsto false, E} \\

\finfrule
{\opsenv e \mapsto null, E}
{\opsenv \text{isnull}(e) \mapsto true, E} \\

\finfrule
{\opsenv e \mapsto v, E}
{\opsenv \text{upregion}(e, \oton{r}) \mapsto v, E}

\finfrule
{\begin{array}{l}
\opsenv e \mapsto v, E \\
v' = \begin{cases}
v, & \text{if $v \not= null$ and $\exists i, v \in M(r_i)$}. \\
null, & \text{otherwise}.
\end{cases}
\end{array}}
{\opsenv \text{downregion}(e, \oton{r}) \mapsto v', E} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto l, E \\
S' = \text{apply}(S, E, C) \\
v = S'[l]
\end{array}}
{\opsenv \text{read}(e_1) \mapsto v, E ++ [ read(l, v) ]} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto l, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvs{S'} e_2 \mapsto v, E_2 \\
\end{array}}
{\opsenv \text{write}(e_1, e_2) \mapsto true, E_1 ++ E_2 ++ [ write(l, v) ]} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto l, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvs{S'} e_2 \mapsto v, E_2 \\
\end{array}}
{\opsenv \text{reduce}(id, e_1, e_2) \mapsto true, E_1 ++ E_2 ++ [ reduce_{id}(l, v) ]} \\

\framebox{$\opsenv \text{newcolor }r \mapsto \emptyset, []$} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto K, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvs{S'} e_2 \mapsto l, E_2 \\
S'' = \text{apply}(S', E_2, C) \\
\opsenvs{S''} e_3 \mapsto v, E_3 \\
K' = \{ (l,v) \} \cup \{ (l_i,v_i) : (l_i,v_i) \in K \wedge l \not= l_i \}
\end{array}}
{\opsenv \text{color}(e_1, e_2, e_3) \mapsto K', E_1 ++ E_2 ++ E_3} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto v_1, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvs{S'} e_2 \mapsto v_2, E_2 \\
v' = v_1 + v_2
\end{array}}
{\opsenv e_1 + e_2 \mapsto v', E_1 ++ E_2} \hspace{1cm}

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto v_1, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvs{S'} e_2 \mapsto v_2, E_2 \\
v' = \begin{cases}
true, & \text{if $v_1 < v_2$}. \\
false, & \text{otherwise}.
\end{cases}
\end{array}}
{\opsenv e_1 < e_2 \mapsto v', E_1 ++ E_2} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto v_1, E_1 \\
L' = L[v_1/id] \\
S' = \text{apply}(S, E_1, C) \\
\opsenvls{L'}{S'} e_2 \mapsto v_2, E_2
\end{array}}
{\opsenv \text{let }id : T = e_1\text{ in }e_2 \mapsto v_2, E_1 ++ E_2} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto true, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvls{L'}{S'} e_2 \mapsto v_2, E_2
\end{array}}
{\opsenv \text{if }e_1\text{ then }e_2\text{ else }e_3 \mapsto v_2, E_1 ++ E_2} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto false, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvls{L'}{S'} e_3 \mapsto v_3, E_3
\end{array}}
{\opsenv \text{if }e_1\text{ then }e_2\text{ else }e_3 \mapsto v_3, E_1 ++ E_3} \\

\finfrule
{\begin{array}{l}
\opsenv e_1 \mapsto v_1, E_1 \\
S_1 = \text{apply}(S, E_1, C) \\
\opsenv e_2 \mapsto v_2, E_2 \\
\ldots \\
S_n = \text{apply}(S_{n-1}, E_n, C) \\
task id[\otok{k}{r'}](f_1 : T_1, \ldots, f_n : T_n) : T_r, E = e_{n+1} \\
M' = \{ (r'_1, M(r_1)), \ldots (r'_k, M(r_k)) \} \\
L' = \{ (f_1, v_1), \ldots, (f_n, v_n) \} \\
\opsenvmls{M'}{L'}{S_n} e_{n+1} \mapsto v_{n+1}, E_{n+1}
\end{array}}
{\opsenv id[\otok{k}{r}](\oton{e}) \mapsto v_{n+1}, E_1 ++ \ldots ++ E_{n+1}} \\

\finfrule{
\begin{array}{l}
\opsenv e_1 \mapsto K, E_1 \\
\rho_i = \{ l : (l, i) \in K \} \\
M' = M[\rho_1/r_1, \ldots, \rho_k/r_k] \\
S' = \text{apply}(S, E_1, C) \\
\opsenvms{M'}{S'} e_2 \mapsto v, E_2
\end{array}}
{\opsenv \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 \mapsto v, E_1 ++ E_2} \\

\finfrule{
\begin{array}{l}
\opsenv e_1 \mapsto v, E \\
\rho_i = M[r_i] \\
v' = \langle \langle \otok{k}{\rho}, v \rangle \rangle
\end{array}}
{\opsenv \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] \mapsto v', E} \\

\finfrule{
\begin{array}{l}
\opsenv e_1 \mapsto \langle \langle \otok{k}{\rho} , v_1 \rangle \rangle, E_1 \\
M' = M[\rho_1/r_1, \ldots, \rho_k/r_k] \\
L' = L[v_1/id] \\
S' = \text{apply}(S, E_1, C) \\
\opsenvmls{M'}{L'}{S'} e_2 \mapsto v_2, E_2
\end{array}}
{\opsenv \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 \mapsto v_2, E_1 ++ E_2 } \\

\subsection{Soundness of Effects}

If
\begin{enumerate}
\item $\typeenv e : T$
\item $\opsenv e \mapsto v, E$
\end{enumerate}
then for all effects $\epsilon$ in $E$,
\begin{enumerate}
\item if $\epsilon = read(l, v)$, then for some $r$, $reads(r) \in \Phi \wedge l \in M(r)$
\item if $\epsilon = write(l, v)$, then for some $r$, $writes(r) \in \Phi \wedge l \in M(r)$
\item if $\epsilon = reduce(id, l, v)$, then for some $r$, $reduces(id,r) \in \Phi \wedge l \in M(r)$
\end{enumerate}




