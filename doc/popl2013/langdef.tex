\newcommand{\oton}[1]{{#1}_1,\ldots,{#1}_n}
\newcommand{\otok}[2]{{#2}_1,\ldots,{#2}_{#1}}
\newcommand{\dplus}{\text{++}}

% fun latex tricks to make typeenv and opsenv more friendly
\makeatletter
\define@key{typeenv}{G}{\def\typeenv@G{#1}}
\define@key{typeenv}{P}{\def\typeenv@P{#1}}
\define@key{typeenv}{O}{\def\typeenv@O{#1}}
\newcommand{\typeenvx}[1][]{
{
% default values
\def\typeenv@G{\Gamma}
\def\typeenv@P{\Phi}
\def\typeenv@O{\Omega}
\setkeys{typeenv}{#1}
\typeenv@G, \typeenv@P, \typeenv@O \vdash \,
}}
\newcommand{\typeenv}[3][]{\typeenvx[#1] {#2} : {#3}}
\define@key{opsenv}{M}{\def\opsenv@M{#1}}
\define@key{opsenv}{L}{\def\opsenv@L{#1}}
\define@key{opsenv}{H}{\def\opsenv@H{#1}}
\define@key{opsenv}{S}{\def\opsenv@S{#1}}
\define@key{opsenv}{C}{\def\opsenv@C{#1}}
\newcommand{\opsenvx}[1][]{
{
% default values
\def\opsenv@M{M}
\def\opsenv@L{L}
\def\opsenv@H{H}
\def\opsenv@S{S}
\def\opsenv@C{C}
\setkeys{opsenv}{#1}
\opsenv@M, \opsenv@L, \opsenv@H, \opsenv@S, \opsenv@C \vdash \,
}}
\newcommand{\opsenv}[4][]{\opsenvx[#1] {#2} \mapsto {#3}, {#4}}
\makeatother

\begin{table*}
\centering
{\small
\begin{tabular}{cclr}

$T$ & ::= &  & types \\
  &$\mid$& bool $\;\;\;\mid\;\;\;$ int & base types \\
  &$\mid$& $\langle T_1, T_2 \rangle$ & tuple \\
  &$\mid$& $T@(\oton{r})$ & pointer \\
  &$\mid$& $\text{coloring}(r)$ & region coloring \\
  &$\mid$& $\exists \oton{r}. T\text{ where }\Omega$ & region relationship \\
  &$\mid$& $\forall \oton{r}. (\oton{T}), \Phi \rightarrow T_r$ & functions \\
\\
$\Omega$ & ::= & $\{ \oton{\omega} \}$ & region constraints \\
$\omega$ & ::= & $r_1 \leq r_2$ & subregion \\
  &$\mid$& $r_1 * r_2$ & disjointness \\
\\
$\Phi$ & ::= & $\{ \oton{\phi} \}$ & privileges \\
$\phi$ & ::= & reads$(r)$ $\;\;\;\mid\;\;\;$ writes$(r)$ $\;\;\;\mid\;\;\;$ reduces$(id,r)$ & \\
\\
$v$ & ::= & & values \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & base values \\
  &$\mid$& $\langle v_1, v_2 \rangle$ & tuple \\
  &$\mid$& null $\;\;\;\mid\;\;\;$ $a$ & address \\
  &$\mid$& $\{ (a_i, iv), \ldots \}$ & coloring \\
  &$\mid$& $\langle \langle \oton{\rho}, v\rangle \rangle$ & region relationship instance \\
\\
$bv$ & ::= & false $\;\;\;\mid\;\;\;$ true \\
\\
$iv$ & ::= & 0 $\;\;\;\mid\;\;\;$ 1 $\ldots$ \\
\\
$e$ & ::= & & expressions \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & constants \\
  &$\mid$& $\langle e_1, e_2 \rangle$ $\;\;\;\mid\;\;\;$ $e$.1 $\;\;\;\mid\;\;\;$ $e$.2 & tuple \\
  &$\mid$& $id$ &  \\
  &$\mid$& $\text{new}\ T@r$ $\;\;\;\mid\;\;\;$ $\text{null }T@r$ $\;\;\;\mid\;\;\;$ $\text{isnull}(e)$ & \\
  &$\mid$& $\text{upregion}(e, r_1,\ldots,r_n)$ $\;\;\;\mid\;\;\;$ $\text{downregion}(e, r_1,\ldots,r_n)$ & \\
  &$\mid$& $\text{read}(e_1)$ $\;\;\;\mid\;\;\;$ $\text{write}(e_1, e_2)$ $\;\;\;\mid\;\;\;$ $\text{reduce}(id, e_1, e_2)$ & memory access \\
  &$\mid$& $\text{newcolor}\ r$ $\;\;\;\mid\;\;\;$ $\text{color}(e_1, e_2, e_3)$ & coloring operations \\
  &$\mid$& $e_1 + e_2$ & integer operations \\
  &$\mid$& $e_1 < e_2$ & comparison operations \\
  &$\mid$& $\text{let}\ id : T = e_1 \text{in}\ e_2$ &  \\
  &$\mid$& $\text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3$ &  \\
  &$\mid$& $id[r_1, \ldots, r_n](e_1,\ldots,e_n)$ & task calls \\
  &$\mid$& $\text{partition}\ r_p\text{ using }e_1\text{ as }\oton{r}\text{ in }\ e_2$ &  \\
  &$\mid$& $\text{pack}\ e_1\ \text{as}\ T[r_1,\ldots,r_n]$ &  \\
  &$\mid$& $\text{unpack}\ e_1\ \text{as}\ id : T[r_1,\ldots,r_n]\ \text{in}\ e_2$ &  \\

\end{tabular}
}
\caption{Types}
\end{table*}

%\newcommand{\infrule}[2]{\displaystyle\frac{\displaystyle\strut{#1}}{\displaystyle\strut {#2}}}
\newcommand{\cinfrule}[3]{\parbox{14cm}{\hfil$\infrule{#1}{#2}$\hfil}\parbox{4cm}{$\,#3$\hfil}}
\newcommand{\finfrule}[2]{\vspace{10pt}\framebox{$\infrule{#1}{#2}$}\vspace{10pt}}

\newcommand{\infx}[2]{\infrule{\begin{array}{l}{#1}\end{array}}{#2}}

\pagebreak

Type rules:

\framebox{$\typeenv{bv}{bool}$} \hspace{1cm}
\framebox{$\typeenv{iv}{int}$} \\

\finfrule
{\begin{array}{l}
\typeenvx e_1 : T_1 \\
\typeenvx e_2 : T_2
\end{array}}
{\typeenvx \langle e_1, e_2 \rangle : \langle T_1, T_2 \rangle} \\

\finfrule{\typeenvx e : \langle T_1,T_2 \rangle}{\typeenvx e\text{.1}\ : T_1} \hspace{1cm}
\finfrule{\typeenvx e : \langle T_1,T_2 \rangle}{\typeenvx e\text{.2}\ : T_2} \\

\finfrule{\Gamma(id) = T}{\typeenvx id : T} \\

\framebox{$\typeenvx \text{null }T@r : T@r$} \hspace{1cm}
\framebox{$\typeenvx \text{new }T@r : T@r$} \\

\finfrule{\typeenvx e : T@(\oton{r})}{\typeenvx \text{isnull}(e) : bool} \\

\finfrule
{\begin{array}{l}
\typeenvx e : T@(\otok{k}{r'}) \\
\forall i. \exists j, r'_i \leq r_j \in \Omega^* \\
\end{array}}
{\typeenvx upregion(e,\oton{r}) : T@(\oton{r})} \\

\finfrule
{\begin{array}{l}
\typeenvx e : T@(\otok{k}{r'}) \\
\forall j. \exists i, r_j \leq r'_i \in \Omega^* \\
\end{array}}
{\typeenvx downregion(e,\oton{r}) : T@(\oton{r})} \\

\finfrule
{\begin{array}{l}
\typeenvx e_1 : T@(\oton{r}) \\
\forall i, reads(r_i) \in \Phi^*\end{array}}
{\typeenvx \text{read}(e_1) : T} \\

\finfrule
{\begin{array}{l}
\typeenvx e_1 : T@(\oton{r}) \\
\typeenvx e_2 : T \\
\forall i, writes(r_i) \in \Phi^*
\end{array}}
{\typeenvx \text{write}(e_1, e_2) : bool} \\

\finfrule
{\begin{array}{l}
\Gamma(id) = (T_1, T_2), \emptyset \rightarrow T_1 \\
\typeenvx e_1 : T_1@(\oton{r}) \\
\typeenvx e_2 : T_2 \\
\forall i, reduces(id, r_i) \in \Phi^*
\end{array}}
{\typeenvx \text{reduce}(id, e_1, e_2) : bool} \\

\framebox{$\typeenvx \text{newcolor }r : \text{coloring}(r)$} \\

\finfrule{\begin{array}{l}
\typeenvx e_1 : \text{coloring}(r) \\
\typeenvx e_2 : T@r \\
\typeenvx e_3 : int
\end{array}}
{\typeenvx \text{color}(e_1, e_2, e_3) : \text{coloring}(r)} \\

\finfrule{\begin{array}{l}\typeenvx e_1 : int \\ \typeenvx e_2 : int\end{array}}{\typeenvx e_1 + e_2 : int} \hspace{1 cm}
\finfrule{\begin{array}{l}\typeenvx e_1 : int \\ \typeenvx e_2 : int\end{array}}{\typeenvx e_1 < e_2 : bool} \\

\finfrule{\begin{array}{l}
\typeenvx e_1 : T_1 \\
\Gamma' = \Gamma[id/T_1] \\
\typeenvx[G=\Gamma'] e_2 : T_2
\end{array}}
{\typeenvx : \text{let}\ id : T_1 \text{in}\ e_2 : T_2} \\

\finfrule{\begin{array}{l}\typeenvx e_1 : bool \\ \typeenvx e_2 : T \\ \typeenvx e_3 : T\end{array}}{\typeenvx \text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3 : T} \\

\finfrule{
\begin{array}{l}
\Gamma(id) = \forall \otok{k}{r'}.(\oton{T}),\Phi_i \rightarrow T_r \\
\typeenvx e_i : T_i[r_1/r'_1,\ldots,r_k/r'_k] \\
\Phi_i[r_1/r'_1,\ldots,r_k/r'_k] \subseteq \Phi^*
\end{array}}
{\typeenvx id[\otok{k}{r}](\oton{e}) : T_r[r_1/r'_1,\ldots,r_k/r'_k]} \\

\finfrule{
\begin{array}{l}
\typeenvx e_1 : \text{coloring}(r_p) \\
\Omega' = \Omega \wedge \bigwedge_{i \in [1,k]} r_i \leq r_p \wedge \bigwedge_{i \not= j} r_i * r_j \\
\typeenvx[O=\Omega'] e_2 : T \\
r_i \not\in \textit{regions\_of}(\Gamma, T)
\end{array}}
{\typeenvx \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 : T} \\

\finfrule{
\begin{array}{l}
T_1 = \exists \otok{k}{r'}. T_2\text{ where }\Omega_1 \\
\Omega \models \Omega_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\typeenvx e_1 : T_2[r_1/r'_1,\ldots,r_k/r'_k]
\end{array}}
{\typeenvx \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] : T_1} \\

\finfrule{
\begin{array}{l}
T_1 = \exists \otok{k}{r'}. T_2\text{ where }\Omega_1 \\
\typeenvx e_1 : T_1 \\
\Gamma' = \Gamma[T_2[r_1/r'_1,\ldots,r_k/r'_k] / id] \\
\Omega' = \Omega \wedge \Omega_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\typeenvx[G=\Gamma',O=\Omega'] e_2 : T_3 \\
r_i \not\in \textit{regions\_of}(\Gamma, T_1, T_3)
\end{array}}
{\typeenvx \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 : T_3} \\

\subsection{Closure of region constraints and priviledges}

\framebox{
$\begin{array}{l}
\Omega \subseteq \Omega^* \\
r_i \leq r_j \in \Omega^*  \Rightarrow r_i \leq r_i \in \Omega^*\wedge r_j \leq r_j \in \Omega^* \\
r_i \leq r_j \in \Omega^* \wedge r_j \leq r_k \in \Omega^* \Rightarrow r_i \leq r_k \in \Omega^* \\
r_i \leq r_j \in \Omega^* \wedge r_j * r_k \in \Omega^* \Rightarrow r_i * r_k \in \Omega^* \\
r_i * r_j \in \Omega^* \Rightarrow r_j * r_i \in \Omega^* \\
\end{array}$
} \\
\framebox{
$\begin{array}{l}
\Phi \subseteq \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge reads(r_j) \in \Phi^* \Rightarrow reads(r_i) \in \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge writes(r_j) \in \Phi^* \Rightarrow writes(r_i) \in \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge reduces(id, r_j) \in \Phi^* \Rightarrow reduces(id, r_i) \in \Phi^* \\
reads(r) \in \Phi^* \wedge writes(r) \in \Phi^* \wedge \\
\hspace{1cm} \Gamma(id) = \forall \otok{k}{r}. (\oton{T}), E \rightarrow T_r \Rightarrow reduces(id, r) \in \Phi^*
\end{array}$
}

\subsection{Operational Semantics}

Operational semantics rules have the following form: \\

\framebox{$\opsenv{e}{v}{E}$}

where: 
\begin{itemize}
\item $M$ is the mapping from logical regions $r_i$ in types to physical regions $\rho_i$, which are sets of memory locations
\item $L$ is the mapping of local variable names to their values
\item $H$ is the heap typing, mapping from memory locations to types
\item $S$ is the store, mapping from memory locations $l_i$ to values
\item $C$ is the ``clobber set'', a set of memory locations that may be accessed by concurrently executing operations (??? does this need to be split into read/write/reduce?)
\item $e$ is the expression being evaluated
\item $v$ is the result of the evaluation
\item $E$ is a memory trace (i.e. the effects) of the execution, a list of read/write/reduce operations in the order they were performed
\end{itemize}

\framebox{$\opsenvx bv \mapsto bv, []$} \hspace{1cm}
\framebox{$\opsenvx iv \mapsto iv, []$} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S' = apply(S, E_1, C) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2
\end{array}}
{\opsenvx \langle e_1, e_2 \rangle \mapsto \langle v_1, v_2 \rangle, E_1 \dplus E_2} \\

\finfrule
{\opsenvx e \mapsto \langle v_1, v_2 \rangle, E}
{\opsenvx e\text{.1} \mapsto v_1, E} \hspace{1cm}
\finfrule
{\opsenvx e \mapsto \langle v_1, v_2 \rangle, E}
{\opsenvx e\text{.2} \mapsto v_2, E} \\

\finfrule
{L(id) = v}
{\opsenvx id \mapsto v, []} \\

\framebox{$\opsenvx \text{null }T@r \mapsto null, []$} \\

\finfrule
{\begin{array}{l}
l \in M(r) \\
H(l) = T[M]
\end{array}}
{\opsenvx \text{new }T@r \mapsto l, []} \\

\finfrule
{\opsenvx e \mapsto v, E}
{\opsenvx \text{isnull}(e) \mapsto false, E} \\

\finfrule
{\opsenvx e \mapsto null, E}
{\opsenvx \text{isnull}(e) \mapsto true, E} \\

\finfrule
{\opsenvx e \mapsto v, E}
{\opsenvx \text{upregion}(e, \oton{r}) \mapsto v, E}

\finfrule
{\begin{array}{l}
\opsenvx e \mapsto v, E \\
v' = \begin{cases}
v, & \text{if $v \not= null$ and $\exists i, v \in M(r_i)$}. \\
null, & \text{otherwise}.
\end{cases}
\end{array}}
{\opsenvx \text{downregion}(e, \oton{r}) \mapsto v', E} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto l, E \\
S' = \text{apply}(S, E, C) \\
v = S'[l]
\end{array}}
{\opsenvx \text{read}(e_1) \mapsto v, E \dplus [ read(l, v) ]} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto l, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[S=S'] e_2 \mapsto v, E_2 \\
\end{array}}
{\opsenvx \text{write}(e_1, e_2) \mapsto true, E_1 \dplus E_2 \dplus [ write(l, v) ]} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto l, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[S=S'] e_2 \mapsto v, E_2 \\
\end{array}}
{\opsenvx \text{reduce}(id, e_1, e_2) \mapsto true, E_1 \dplus E_2 \dplus [ reduce_{id}(l, v) ]} \\

\framebox{$\opsenvx \text{newcolor }r \mapsto \emptyset, []$} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto K, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[S=S'] e_2 \mapsto l, E_2 \\
S'' = \text{apply}(S', E_2, C) \\
\opsenvx[S=S''] e_3 \mapsto v, E_3 \\
K' = \{ (l,v) \} \cup \{ (l_i,v_i) : (l_i,v_i) \in K \wedge l \not= l_i \}
\end{array}}
{\opsenvx \text{color}(e_1, e_2, e_3) \mapsto K', E_1 \dplus E_2 \dplus E_3} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2 \\
v' = v_1 + v_2
\end{array}}
{\opsenvx e_1 + e_2 \mapsto v', E_1 \dplus E_2} \hspace{1cm}

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2 \\
v' = \begin{cases}
true, & \text{if $v_1 < v_2$}. \\
false, & \text{otherwise}.
\end{cases}
\end{array}}
{\opsenvx e_1 < e_2 \mapsto v', E_1 \dplus E_2} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
L' = L[v_1/id] \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[L=L',S=S'] e_2 \mapsto v_2, E_2
\end{array}}
{\opsenvx \text{let }id : T = e_1\text{ in }e_2 \mapsto v_2, E_1 \dplus E_2} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto true, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[L=L',S=S'] e_2 \mapsto v_2, E_2
\end{array}}
{\opsenvx \text{if }e_1\text{ then }e_2\text{ else }e_3 \mapsto v_2, E_1 \dplus E_2} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto false, E_1 \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[L=L',S=S'] e_3 \mapsto v_3, E_3
\end{array}}
{\opsenvx \text{if }e_1\text{ then }e_2\text{ else }e_3 \mapsto v_3, E_1 \dplus E_3} \\

\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S_1 = \text{apply}(S, E_1, C) \\
\opsenvx e_2 \mapsto v_2, E_2 \\
\ldots \\
S_n = \text{apply}(S_{n-1}, E_n, C) \\
task id[\otok{k}{r'}](f_1 : T_1, \ldots, f_n : T_n) : T_r, E = e_{n+1} \\
M' = \{ (r'_1, M(r_1)), \ldots (r'_k, M(r_k)) \} \\
L' = \{ (f_1, v_1), \ldots, (f_n, v_n) \} \\
\opsenvx[M=M',L=L',S=S_n] e_{n+1} \mapsto v_{n+1}, E_{n+1}
\end{array}}
{\opsenvx id[\otok{k}{r}](\oton{e}) \mapsto v_{n+1}, E_1 \dplus \ldots \dplus E_{n+1}} \\

\finfrule{
\begin{array}{l}
\opsenvx e_1 \mapsto K, E_1 \\
\rho_i = \{ l : (l, i) \in K \} \\
M' = M[\rho_1/r_1, \ldots, \rho_k/r_k] \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[M=M',S=S'] e_2 \mapsto v, E_2
\end{array}}
{\opsenvx \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 \mapsto v, E_1 \dplus E_2} \\

\finfrule{
\begin{array}{l}
\opsenvx e_1 \mapsto v, E \\
\rho_i = M[r_i] \\
v' = \langle \langle \otok{k}{\rho}, v \rangle \rangle
\end{array}}
{\opsenvx \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] \mapsto v', E} \\

\finfrule{
\begin{array}{l}
\opsenvx e_1 \mapsto \langle \langle \otok{k}{\rho} , v_1 \rangle \rangle, E_1 \\
M' = M[\rho_1/r_1, \ldots, \rho_k/r_k] \\
L' = L[v_1/id] \\
S' = \text{apply}(S, E_1, C) \\
\opsenvx[M=M',L=L',S=S'] e_2 \mapsto v_2, E_2
\end{array}}
{\opsenvx \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 \mapsto v_2, E_1 \dplus E_2 } \\

\subsection{Soundness of Effects}

If
\begin{enumerate}
\item $\typeenvx e : T$
\item $\opsenvx e \mapsto v, E$
\end{enumerate}
we would like to prove that all of the dynamic effects described by $E$ are
included in the static privileges $\Phi$.  A judgement $E : \Phi$ means that
for all effects $\epsilon$ in $E$,
\begin{enumerate}
\item if $\epsilon = read(l, v)$, then for some $r$, $reads(r) \in \Phi \wedge l \in M(r)$
\item if $\epsilon = write(l, v)$, then for some $r$, $writes(r) \in \Phi \wedge l \in M(r)$
\item if $\epsilon = reduce(id, l, v)$, then for some $r$, $reduces(id,r) \in \Phi \wedge l \in M(r)$
\end{enumerate}

\subsection{Strategy}

\newcommand{\llbracket}{[\![}
\newcommand{\rrbracket}{]\!]}

The mapping $M$ is a function from logical region names $r$ to physical regions $\rho$.  It will
be convenient to apply $M$ to types and even functions that operate on types by defining
$\hat x = M \llbracket x \rrbracket$ to be $x$ with all logical region names $r_i$ replaced by their
corresponding physical region $\rho_i = M(r_i)$.  Note that $M \llbracket x \rrbracket$ is not
well-formed if it contains a logical region name $r_j \not\in dom(M)$. \\

Soundness is proven using induction over the structure of an expression.  A number of properties
are assumed and/or proven at each step: 
\begin{enumerate}
\item $M \sim \Omega \Leftrightarrow (\forall r_i, r_j. r_i \leq r_j \in \Omega \rightarrow M(r_i) \subseteq M(r_j)) \wedge (\forall r_i, r_j. r_i * r_j \in \Omega \rightarrow M(r_i) \cap M(r_j) = \emptyset)$, that M is an $\Omega$-satisfying mapping of logical regions to physical regions
\item $\hat T = M \llbracket T \rrbracket$, a {\em physical type}, constructed by replacing all of the free region names $r$ in T with the physical regions $\rho = M(r)$
\item $v \sim_H \hat T$, value consistency with respect to a heap typing.  Value consistency is
itself defined inductively over the structure of a type:
\begin{enumerate}
\item $bv \sim_H bool$
\item $iv \sim_H int$
\item $null \sim_H T@\rho$
\item $l \sim_H T@\rho \Leftrightarrow (l \in \rho) \wedge (H(l) \sim_H T)$
\item $\langle v_1, v_2 \rangle \sim_H \langle \hat T_1, \hat T_2 \rangle \Leftrightarrow (v_1 \sim_H \hat T_1) \wedge (v_2 \sim_H \hat T_2)$
\item $\langle \langle \oton{\rho}, v \rangle \rangle \sim_H \text{rr}[\oton{r}] \hat T\text{ where }\Omega \Leftrightarrow (v \sim_H \hat T[\rho_1/r_1, \ldots \rho_n/r_n]) \wedge (\{ (r_i, \rho_i) \} \sim \Omega)$
\item $K \sim_H coloring(\rho) \Leftrightarrow \forall l_1, v_1. (l_1, v_1) \in K \rightarrow (l_1 \in \rho \wedge \forall l_2, v_2. (l_2, v_2) \in K \rightarrow (l_1 \not= l_2) \vee (v_1 = v_2))$
\end{enumerate}
\item $L \sim_H M \llbracket \Gamma \rrbracket \Leftrightarrow \forall (id,v) \in L. v \sim_H M \llbracket \Gamma \rrbracket (id) $, local stack consistency with respect to a heap typing
\item $S \sim H \Leftrightarrow \forall (l,v) \in S. v \sim_H H(l)$, store consistency with respect to a given heap typing
\item $E \sim H \Leftrightarrow (\forall l, v. write(l,v) \in E \rightarrow v \sim_H H(l)) \wedge (\forall id, l, v. reduce_{id}(l, v) \in E \rightarrow (\hat \Gamma (id) = (\hat T_1, \hat T_2), \emptyset \rightarrow \hat T_1) \wedge H(l) = \hat T_1 \wedge v \sim_H \hat T_2)$, effect consistnecy with respect to a given heap typing
\end{enumerate}

Armed with all of these, we look at the following property:
\begin{enumerate}
\item $E \sim_H \Phi$, containment of effects within privileges
\end{enumerate}

and prove

\finfrule
{\begin{array}{l}
\typeenvx e : T \\
\opsenvx e \mapsto v, E \\
M \sim \Omega \hspace{1cm}
L \sim_H \Gamma \hspace{1cm}
S \sim H
\end{array}}
{
v \sim_H M \llbracket T \rrbracket \hspace{1cm}
E \sim H \hspace{1cm}
E : \Phi
}

A few lemmas will be useful:

\finfrule
{\begin{array}{l}
S \sim H \hspace{1cm}
E \sim H
\end{array}}
{ \text{apply}(S, E, C) \sim H }

\finfrule
{\begin{array}{l}
E_1 \sim H \hspace{1cm}
E_2 \sim H
\end{array}}
{ E_1 \dplus E_2 \sim H } \\

\finfrule
{\begin{array}{l}
E_1 : \Phi \hspace{1cm}
E_2 : \Phi
\end{array}}
{ E_1 \dplus E_2 : \Phi } \\

\framebox{$M \sim \Omega \Leftrightarrow M \sim \Omega^*$} \\

\framebox{$E : \Phi \Leftrightarrow E : \Phi^*$}

\begin{table*}
\centering
{\small
\begin{tabular}{l|p{5cm}|p{5cm}|p{5cm}}
{\bf Rule} & 
\multicolumn{1}{|c|}{$\mathbf{v \sim_H M \llbracket T \rrbracket}$} &
\multicolumn{1}{|c|}{$\mathbf{E \sim H}$} &
\multicolumn{1}{|c|}{$\mathbf{E : \Phi}$} \\
\hline
BoolConst & & & \\
IntConst & & & \\
TupleBuild & & & \\
TupleField & & & \\
LocalVar & & & \\
NullPtr & & & \\
NewPtr & & & \\
IsNull & & & \\
UpRegion & & & \\
DownRegion & & & \\
Read & & & \\
Write & & & \\
Reduce & & & \\
Newcolor & & & \\
Color & & & \\
IntMath & & & \\
IntCmp & & & \\
Let & & & \\
IfElse & & & \\
TaskCall & & & \\
Partition & & & \\
Pack & & & \\
Unpack & & &
\end{tabular}}
\caption{Proof pieces}
\end{table*}


\subsection{Noninterference}

For a given expression $e$, we can consider $v^o$ to be a ``sequential'' result and $E^o$ to be the corresponding ``sequential'' effects if: \\

\framebox{$M, L, H, S, \emptyset \vdash e \mapsto v^o, E^o$} \\

(i.e. if there are no manipulations of the store other than what's done by
the evaluation of the expression $e$.)  We now wish to consider what parallel
evaluations of this expression with other expression evaluations will still
yield our ``sequential'' result. \\

Two effects are considered to be noninterfering, written $E_1 \# E_2$ if for
every $\epsilon_1$ in $E_1$ and every $\epsilon_2$ in $E_2$,
\begin{enumerate}
\item $\epsilon_1$ and $\epsilon_2$ are to different memory locations, or
\item $\epsilon_1 = read(l, v_1)$ and $\epsilon_2 = read(l, v_2)$, or
\item $\epsilon_1 = reduce_{id}(l, v_1)$ and $\epsilon_2 = reduce_{id}(l, v_2)$
\end{enumerate}

We define nonintereference (under a given mapping $M$) of static privileges
$\Phi_1$ and $\Phi_2$ similarly.  We use the following table for determining
noninterference of two individual priviledges $\phi_1$ and $\phi_2$:

\begin{tabular}{ccccc}
\multicolumn{2}{l}{$\phi_1 \#_M \phi_2 ?$} & \multicolumn{3}{c}{$\phi_2$} \\
\multicolumn{2}{l}{} & $reads(r_2)$ & $writes(r_2)$ & $reduces(id_2, r_2)$ \\
\multirow{3}{*}{$\phi_1$} & $reads(r_1)$ & true & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$\\
& $writes(r_1)$ & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$ \\
& $reduces(id_1, r_1)$ & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$ & $\begin{array}{l}id_1 = id_2 \vee \\ M(r_1) \cap M(r_2) = \emptyset\end{array}$
\end{tabular}

We can then define: \\

\framebox{$\Phi_1 \#_M \Phi_2 \Leftrightarrow \displaystyle\bigwedge_{\begin{array}{c}\phi_1 \in \Phi_1 \\ \phi_2 \in \Phi_2 \end{array}} \phi_1 \#_M \phi_2$} \\

From the soundness of effects, result, we can show that for two expressions
$e_1$ and $e_2$, if their privileges are noninterfering, any potential memory
traces from their evaluation must also be noninterfering.  Formally:

\finfrule
{\begin{array}{l}
\typeenvx[P=\Phi_1] e_1 : T_1 \\
\typeenvx[P=\Phi_2] e_2 : T_2 \\
\opsenvx e_1 \mapsto v_1, E_1 \\
\opsenvx e_2 \mapsto v_2, E_2 \\
\Phi_1 \#_M \Phi_2
\end{array}}
{E_1 \# E_2}

(TODO: Generalize this further and allow $M_1 \not= M_2$?) \\

Note that this result holds even if $C \not= \emptyset$.  This allows 
two ``locally independent'' subtasks to run in parallel even if one or both
of them is interacting (in a programmer-permitted way) with a third subtask.

Noninterference of effects is something that can only be determined after
evaluation of an expression is completed, and only at great expense (see STM).
In contrast, the noninterference of privileges can be efficiently determined at
runtime.  Even though the privileges themselves are static, the
mapping $M$ can be dynamically determined, allowing noninterference to be 
judged in many more cases than a purely static analysis can achieve.

(TODO: Talk about coherence modes and how the runtime orders subtasks.  Maybe
describe it in terms of a ``canonical'' memory trace and then allow
reorderings?)

\subsection{Hierarchical Scheduling}

Let $e_1$ and $e_2$ be expressions that require privileges $\Phi_1$ and
$\Phi_2$.  Now let $e_3$ be some subexpression of $e_1$ and $e_4$ be some 
subexpression of $e_2$, with corresponding privileges $\Phi_3$ and $\Phi_4$.

Proper scheduling of the evaluation of $e_3$ and $e_4$ depends on whether
they interfere.  If they do intefere (and must therefore be serialized), we
will have $E_3 \cancel\# E_4$, and by the above result, $\Phi_3 \cancel\# \Phi_4$. 

We now show that this will also imply that $\Phi_1 \cancel\# \Phi_2$, and
unless sequential behavior has been relaxed by the programmer, the
evaluations of $e_1$ and $e_2$ will be serialized.  Since the evaluation of
$e_3$ is a subsequence of the evaluation of $e_1$ and the evaluation of $e_4$
is a subsequence of the evaluation of $e_2$, the evaluations of $e_3$ and $e_4$
are properly serialized as well.

Conversely, if $e_1$ and $e_2$ are judged to be noninterfering, the schedule
does not need to check for interference between $e_3$ and $e_4$, as their
noninterference is guaranteed.

Proof is straightforward once armed with the following lemmas:

\framebox{$\Phi_1 \#_M \Phi_2 \Leftrightarrow \Phi_1^* \#_M \Phi_2^*$}

\framebox{$\Phi_1 \#_M \Phi_2 \wedge \Phi_3 \subseteq \Phi_2 \Rightarrow \Phi_1 \#_M \Phi_3$}

