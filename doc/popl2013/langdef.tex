\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}

\newcommand{\oton}[1]{{#1}_1,\ldots,{#1}_n}
\newcommand{\otok}[2]{{#2}_1,\ldots,{#2}_{#1}}
\newcommand{\dplus}{\text{++}}
\newcommand{\llbracket}{[\![}
\newcommand{\rrbracket}{]\!]}

% fun latex tricks to make typeenv and opsenv more friendly
\makeatletter
\define@key{typeenv}{G}{\def\typeenv@G{#1}}
\define@key{typeenv}{P}{\def\typeenv@P{#1}}
\define@key{typeenv}{O}{\def\typeenv@O{#1}}
\newcommand{\typeenvx}[1][]{
{
% default values
\def\typeenv@G{\Gamma}
\def\typeenv@P{\Phi}
\def\typeenv@O{\Omega}
\setkeys{typeenv}{#1}
\typeenv@G, \typeenv@P, \typeenv@O \vdash \,
}}
\newcommand{\typeenv}[3][]{\typeenvx[#1] {#2} : {#3}}
\define@key{opsenv}{M}{\def\opsenv@M{#1}}
\define@key{opsenv}{L}{\def\opsenv@L{#1}}
\define@key{opsenv}{H}{\def\opsenv@H{#1}}
\define@key{opsenv}{S}{\def\opsenv@S{#1}}
\define@key{opsenv}{C}{\def\opsenv@C{#1}}
\newcommand{\opsenvx}[1][]{
{
% default values
\def\opsenv@M{M}
\def\opsenv@L{L}
\def\opsenv@H{H}
\def\opsenv@S{S}
\def\opsenv@C{C}
\setkeys{opsenv}{#1}
\opsenv@M, \opsenv@L, \opsenv@H, \opsenv@S, \opsenv@C \vdash \,
}}
\newcommand{\opsenv}[4][]{\opsenvx[#1] {#2} \mapsto {#3}, {#4}}
\makeatother

\begin{figure*}
\centering
{\small
\begin{tabular}{cclr}

$T$ & ::= &  & types \\
  &$\mid$& bool $\;\;\;\mid\;\;\;$ int & base types \\
  &$\mid$& $\langle T_1, T_2 \rangle$ & tuple \\
  &$\mid$& $T@(\oton{r})$ & pointer \\
  &$\mid$& $\text{coloring}(r)$ & region coloring \\
  &$\mid$& $\exists \oton{r}. T\text{ where }\Omega$ & region relationship \\
  &$\mid$& $\forall \oton{r}. (\oton{T}), \Phi, Q \rightarrow T_r$ & functions \\
\\
$\Omega$ & ::= & $\{ \oton{\omega} \}$ & region constraints \\
$\omega$ & ::= & $r_1 \leq r_2$ & subregion \\
  &$\mid$& $r_1 * r_2$ & disjointness \\
\\
$\Phi$ & ::= & $\{ \oton{\phi} \}$ & privileges \\
$\phi$ & ::= & reads$(r)$ $\;\;\;\mid\;\;\;$ writes$(r)$ $\;\;\;\mid\;\;\;$ reduces$(id,r)$ & \\
\\
$Q$ & ::= & $\{ \oton{q} \}$ & coherence modes \\
$q$ & ::= & atomic$(r)$ $\;\;\;\mid\;\;\;$ simult$(r)$ & \\
\\
$v$ & ::= & & values \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & base values \\
  &$\mid$& $\langle v_1, v_2 \rangle$ & tuple \\
  &$\mid$& null $\;\;\;\mid\;\;\;$ $a$ & address \\
  &$\mid$& $\{ (a_i, iv), \ldots \}$ & coloring \\
  &$\mid$& $\langle \langle \oton{\rho}, v\rangle \rangle$ & region relationship instance \\
\\
$bv$ & ::= & false $\;\;\;\mid\;\;\;$ true \\
\\
$iv$ & ::= & 0 $\;\;\;\mid\;\;\;$ 1 $\ldots$ \\
\\
$e$ & ::= & & expressions \\
  &$\mid$& $bv$ $\;\;\;\mid\;\;\;$ $iv$ & constants \\
  &$\mid$& $\langle e_1, e_2 \rangle$ $\;\;\;\mid\;\;\;$ $e$.1 $\;\;\;\mid\;\;\;$ $e$.2 & tuple \\
  &$\mid$& $id$ &  \\
  &$\mid$& $\text{new}\ T@r$ $\;\;\;\mid\;\;\;$ $\text{null }T@r$ $\;\;\;\mid\;\;\;$ $\text{isnull}(e)$ & \\
  &$\mid$& $\text{upregion}(e, r_1,\ldots,r_n)$ $\;\;\;\mid\;\;\;$ $\text{downregion}(e, r_1,\ldots,r_n)$ & \\
  &$\mid$& $\text{read}(e_1)$ $\;\;\;\mid\;\;\;$ $\text{write}(e_1, e_2)$ $\;\;\;\mid\;\;\;$ $\text{reduce}(id, e_1, e_2)$ & memory access \\
  &$\mid$& $\text{newcolor}\ r$ $\;\;\;\mid\;\;\;$ $\text{color}(e_1, e_2, e_3)$ & coloring operations \\
  &$\mid$& $e_1 + e_2$ & integer operations \\
  &$\mid$& $e_1 < e_2$ & comparison operations \\
  &$\mid$& $\text{let}\ id : T = e_1 \text{in}\ e_2$ &  \\
  &$\mid$& $\text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3$ &  \\
  &$\mid$& $id[r_1, \ldots, r_n](e_1,\ldots,e_n)$ & task calls \\
  &$\mid$& $\text{partition}\ r_p\text{ using }e_1\text{ as }\oton{r}\text{ in }\ e_2$ &  \\
  &$\mid$& $\text{pack}\ e_1\ \text{as}\ T[r_1,\ldots,r_n]$ &  \\
  &$\mid$& $\text{unpack}\ e_1\ \text{as}\ id : T[r_1,\ldots,r_n]\ \text{in}\ e_2$ &  \\

\end{tabular}
}
\caption{Legion Core Language}
\label{fig:langdef}
\end{figure*}

%\newcommand{\infrule}[2]{\displaystyle\frac{\displaystyle\strut{#1}}{\displaystyle\strut {#2}}}
\newcommand{\cinfrule}[3]{\parbox{14cm}{\hfil$\infrule{#1}{#2}$\hfil}\parbox{4cm}{$\,#3$\hfil}}
\newcommand{\finfrule}[2]{\framebox{$\infrule{#1}{#2}$}}
\newcommand{\oldfinfrule}[2]{\vspace{10pt}\framebox{$\infrule{#1}{#2}$}\vspace{10pt}}

\newcommand{\infx}[2]{\infrule{\begin{array}{l}{#1}\end{array}}{#2}}

\pagebreak

\section{Legion Core Language}

\subsection{Language Definition}

Figure~\ref{fig:langdef} defines the core subset of Legion application language.
Legion includes basic boolean, integer and tuple types.  Pointers are included as well, but in
addition to specifying the type of value it points to, a pointer's type also constrains where in
memory it can point (i.e. only into regions listed in the type).  A special type exists for
{\em colorings}, which are used to specify how a region should be partitioned into subregions.
Functions in Legion are named, accept one or more arguments and return a value of some type.
A function also declares what region access privileges and coherence it requires.  Function types
are universally quantified over all logical region bindings, with all argument and result types,
as well as the privileges and coherence requirements being expressed relative to the quantified
region names.
The final additional value type that Legion uses is a region relation.  Although logical regions
cannot be stored directly in variables, they can be captured as part of a region relation 
instance, which stores a value and one or more logical regions that satisfy a particular set of
constraints.  An instance of a region relation can be read out of the heap and unpacked, giving
new local names to the logical regions contained in the instance and tracking the constraints
between those new logical regions.

\subsection{Legion Core Type System}

The Legion Core language is explicitly typed, using judgments of the following form:

\begin{center}
$\typeenv{e}{T}$
\end{center}

where:
\begin{itemize}
\item $\Gamma$ is the type environment, mapping the names of local variables and global functions
to their types,
\item $\Phi$ is the region access privileges under which the expression will be evaluated, and
\item $\Omega$ is the set of constraints that must hold between regions
\end{itemize}

As regions are hierarchical, privileges and/or constraints on a region will often imply similar
privileges or constraints on subregions.  Figure~\ref{fig:closure} defines transitive closure
operations for $\Phi^*$ and $\Omega^*$ that will be used in some of the type checking rules.

The full set of type checking rules are in Figure~\ref{fig:types}.  Many of the rules are 
straightforward, but several deserve more explanation.

The Legion core language has no subtyping, even for pointers into regions that are part of a 
known region hierarchy.  The region ``scope'' of a pointer can only be changed via explicit
{\em upregion} and {\em downregion} operations, which check that the ``from'' and ``to'' regions
are in the right relationship.  It would have been possible to safely infer {\em upregion} calls,
but {\em downregion} calls must be accompanied by a run-time check that the pointer really does
point into the subregion(s), so {\em upregion} was made explicit as well for simplicity.

Accesses to heap memory are performed via the {\em read}, {\em write}, and {\em reduce}
operations, which are only legal if the region(s) in a pointers type are ones for which the
enclosing function has privileges to access.

Similarly, a call to another function is only permitted if the privileges required by the 
callee are a subset of those held by the caller.  There is no way to create privileges within
a Legion function - it is limited to those given to it by its caller.

The {\em partition} operation uses a {\em coloring} to split a region into one or more
disjoint subregions.  The subregions are given names within the body of the {\em partition},
as well as constraints that assert that each subregion is contained by the parent region and
the pairwise disjointness of the subregions.  These constraints can be used locally, or packed
into region relation instances that can be unpacked and used later.

The {\em pack} expression packs together a value and the corresponding set of logical regions,
as long as the constraints in the region relationship type can be shown to hold.  The
corresponding {\em unpack} expression gives (new) names to those regions.  Neither the 
{\em partition} nor the {\em unpack} expression allows aliasing of region names, simplifying the
handling of existing variables and region names.

\begin{figure*}
\centering{
\framebox{$\typeenv{bv}{bool}$}
\framebox{$\typeenv{iv}{int}$}
\finfrule
{\begin{array}{l}
\typeenvx e_1 : T_1 \\
\typeenvx e_2 : T_2
\end{array}}
{\typeenvx \langle e_1, e_2 \rangle : \langle T_1, T_2 \rangle}
\finfrule{\typeenvx e : \langle T_1,T_2 \rangle}{\typeenvx e\text{.1}\ : T_1}
\finfrule{\typeenvx e : \langle T_1,T_2 \rangle}{\typeenvx e\text{.2}\ : T_2}
\finfrule{\Gamma(id) = T}{\typeenvx id : T}
\framebox{$\typeenvx \text{null }T@r : T@r$}
\framebox{$\typeenvx \text{new }T@r : T@r$}
\finfrule{\typeenvx e : T@(\oton{r})}{\typeenvx \text{isnull}(e) : bool}
\finfrule
{\begin{array}{l}
\typeenvx e : T@(r'_1, \ldots r'_k) \\
\forall i. \exists j, r'_i \leq r_j \in \Omega^* \\
\end{array}}
{\typeenvx upregion(e,\oton{r}) : T@(\oton{r})}
\finfrule
{\begin{array}{l}
\typeenvx e : T@(r'_1, \ldots r'_k) \\
\forall j. \exists i, r_j \leq r'_i \in \Omega^* \\
\end{array}}
{\typeenvx downregion(e,\oton{r}) : T@(\oton{r})}
\finfrule
{\begin{array}{l}
\typeenvx e_1 : T@(\oton{r}) \\
\forall i, reads(r_i) \in \Phi^*\end{array}}
{\typeenvx \text{read}(e_1) : T}
\finfrule
{\begin{array}{l}
\typeenvx e_1 : T@(\oton{r}) \\
\typeenvx e_2 : T \\
\forall i, writes(r_i) \in \Phi^*
\end{array}}
{\typeenvx \text{write}(e_1, e_2) : bool}
\finfrule
{\begin{array}{l}
\Gamma(id) = (T_1, T_2), \emptyset, \emptyset \rightarrow T_1 \\
\typeenvx e_1 : T_1@(\oton{r}) \\
\typeenvx e_2 : T_2 \\
\forall i, reduces(id, r_i) \in \Phi^*
\end{array}}
{\typeenvx \text{reduce}(id, e_1, e_2) : bool}
\framebox{$\typeenvx \text{newcolor }r : \text{coloring}(r)$}
\finfrule{\begin{array}{l}
\typeenvx e_1 : \text{coloring}(r) \\
\typeenvx e_2 : T@r \\
\typeenvx e_3 : int
\end{array}}
{\typeenvx \text{color}(e_1, e_2, e_3) : \text{coloring}(r)}
\finfrule{\begin{array}{l}\typeenvx e_1 : int \\ \typeenvx e_2 : int\end{array}}{\typeenvx e_1 + e_2 : int}
\finfrule{\begin{array}{l}\typeenvx e_1 : int \\ \typeenvx e_2 : int\end{array}}{\typeenvx e_1 < e_2 : bool}
\finfrule{\begin{array}{l}
\typeenvx e_1 : T_1 \\
\typeenvx[G={\Gamma[id/T_1]}] e_2 : T_2
\end{array}}
{\typeenvx : \text{let}\ id : T_1 \text{in}\ e_2 : T_2}
\finfrule{\begin{array}{l}\typeenvx e_1 : bool \\ \typeenvx e_2 : T \\ \typeenvx e_3 : T\end{array}}{\typeenvx \text{if}\ e_1\ \text{then}\ e_2\ \text{else}\ e_3 : T}
\finfrule{
\begin{array}{l}
\Gamma(id) = \forall r'_1, \ldots r'_k.(\oton{T}),\Phi', Q' \rightarrow T_r \\
\typeenvx e_i : T_i[r_1/r'_1,\ldots,r_k/r'_k] \\
\Phi'[r_1/r'_1,\ldots,r_k/r'_k] \subseteq \Phi^*
\end{array}}
{\typeenvx id[\otok{k}{r}](\oton{e}) : T_r[r_1/r'_1,\ldots,r_k/r'_k]}
\finfrule{
\begin{array}{l}
\typeenvx e_1 : \text{coloring}(r_p) \\
\Omega' = \Omega \wedge \bigwedge_{i \in [1,k]} r_i \leq r_p \wedge \bigwedge_{1 \leq i < j \leq k} r_i * r_j \\
\typeenvx[O=\Omega'] e_2 : T \\
\{ \oton{r} \} \cap \textit{regions\_of}(\Gamma, T) = \emptyset
\end{array}}
{\typeenvx \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 : T}
\finfrule{
\begin{array}{l}
T_1 = \exists r'_1, \ldots r'_n.\ T_2\text{ where }\Omega_1 \\
\Omega_1[r_1/r'_1,\ldots,r_k/r'_k] \subseteq \Omega^* \\
\typeenvx e_1 : T_2[r_1/r'_1,\ldots,r_k/r'_k]
\end{array}}
{\typeenvx \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] : T_1}
\finfrule{
\begin{array}{l}
T_1 = \exists r'_1, \ldots, r'_n.\ T_2\text{ where }\Omega_1 \\
\typeenvx e_1 : T_1 \\
\Gamma' = \Gamma[T_2[r_1/r'_1,\ldots,r_k/r'_k] / id] \\
\Omega' = \Omega \cup \Omega_1[r_1/r'_1,\ldots,r_k/r'_k] \\
\typeenvx[G=\Gamma',O=\Omega'] e_2 : T_3 \\
\{ \oton{r} \} \cap \textit{regions\_of}(\Gamma, T_1, T_3) = \emptyset
\end{array}}
{\typeenvx \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 : T_3}
}
\caption{Legion Core Type System}
\label{fig:types}
\end{figure*}

\begin{figure}
\centering{
$\begin{array}{l}
\Omega \subseteq \Omega^* \\
r_i \leq r_j \in \Omega^*  \Rightarrow r_i \leq r_i \in \Omega^*\wedge r_j \leq r_j \in \Omega^* \\
r_i \leq r_j \in \Omega^* \wedge r_j \leq r_k \in \Omega^* \Rightarrow r_i \leq r_k \in \Omega^* \\
r_i \leq r_j \in \Omega^* \wedge r_j * r_k \in \Omega^* \Rightarrow r_i * r_k \in \Omega^* \\
r_i * r_j \in \Omega^* \Rightarrow r_j * r_i \in \Omega^* \\
\\
\Phi \subseteq \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge reads(r_j) \in \Phi^* \Rightarrow reads(r_i) \in \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge writes(r_j) \in \Phi^* \Rightarrow writes(r_i) \in \Phi^* \\
r_i \leq r_j \in \Omega^* \wedge reduces(id, r_j) \in \Phi^* \Rightarrow reduces(id, r_i) \in \Phi^* \\
reads(r) \in \Phi^* \wedge writes(r) \in \Phi^* \wedge \\
\hspace{1cm} \Gamma(id) = \forall \otok{k}{r}. (\oton{T}), \Phi', Q' \rightarrow T_r \Rightarrow reduces(id, r) \in \Phi^*
\end{array}$
}
\caption{Privilege and Constraint Closure}
\label{fig:closure}
\end{figure}

\subsection{Operational Semantics}

Operational semantics rules have the following form:

\begin{center}
$\opsenv{e}{v}{E}$
\end{center}

where: 
\begin{itemize}
\item $M$ is the mapping from logical regions $r_i$ in types to physical regions $\rho_i$, which are sets of memory locations.

It will be useful to apply this logical-to-physical mapping to other
things that defined in terms of logical regions to yield a corresponding definition in terms of
physical regions.  The notation $\hat x = M \llbracket x \rrbracket$ is used to describe the
result of replacing all free logical region names $r_i$ in $x$ with the corresponding physical
region $\rho_i$.  (Note that $M \llbracket x \rrbracket$ is not
well-formed if it contains a free logical region name $r_j \not\in dom(M)$.)
\item $L$ is the mapping of local variable names to their values on the stack.  These values are
immutable, and private to the function - it is not possible to get a pointer to a local value.
\item $H$ is the heap typing, mapping from memory locations to types.  The heap typing does not
change during the execution of a legion program.  The Legion type system is strong enough to
support the use of garbage collection
to allow the reuse of a memory location (potentially with a different type stored in that
location) once all existing references to it are dead, but we
do not consider that further in this paper.
\item $S$ is the store, mapping from memory locations $l_i$ to the current value stored.
\item $C$ is the ``clobber set'', a set of memory locations that may be accessed by concurrently executing operations (??? does this need to be split into read/write/reduce?)
\item $e$ is the expression being evaluated
\item $v$ is the result of the evaluation
\item $E$ is a memory trace (i.e. the effects) of the execution, a list of memory operations
in the order they were performed.  An operation $\epsilon$ is one of the following:
\begin{itemize}
\item $read(l, c, v)$, a read of location $l$ with coherence mode $c$, returning value $v$
\item $write(l, c, v)$, a write to location $l$ with coherence mode $c$, storing value $v$
\item $reduce_{id}(l, c, v)$, a reduction into location $l$ with coherence mode $c$ using a
commutative function $id$ with value $v$
\end{itemize}
where coherence modes are one of ({\em excl}, {\em atomic}, {\em simult}).

The following helper functions are used in some of the rules that deal with memory effects:
\begin{itemize}
\item $apply(S, E)$ is used to determine the effect on the store of a sequence of memory operations
\item $mark\_coherence(E, \hat Q)$ marks the memory operations in a subtask's trace to
constrain how the operations in that trace can be interleaved with other sibling tasks' operations
\item $valid\_interleave(S, C, E', \oton{E})$ is used to determine if $E'$ is a valid way to
interleave the memory traces of two or more subexpressions
\end{itemize}
Figure~\ref{fig:opsemfns} gives the definitions of {\em apply} and {\em mark\_coherence}.  For
the {\em valid\_interleave} predicate, we state some of the necessary conditions here, but leave 
the construction of actual valid interleavings until a later section.  Informally, a interleaving
of two or more memory traces must include all the operations from each trace (and no additional
operations), with each trace's operations remaining in order.  A valid interleaving must further
satisfy the requirement that the value read from the store must yield the most recently 
stored/reduced value unless that location is part of the clobber set $C$.
\end{itemize}

A number of the rules are worth discussing in detail.

Because we would like to keep the heap typing $H$ constant, the semantics for the expression
new $T@r$ allow the choice of any memory location that falls within the right physical region
and has the appropriate heap type.  The soundness of the type system does not depend on that
location being one that isn't already in use, although most implementations will want to 
add that additional guarantee.

A similar choice appears in the semantics of the read operation.  If the location being read
from is within the clobber set $C$, the semantics appear to allow any value to be returned, as
long as it has the right type.  In reality, the choices are more constrained.  If it's not the
most recently written/reduced value from the current expression evaluation, it must at least be
a value written by some concurrent evaluation.  The constraint is applied further up in the 
expression tree when the result of the function is interleaved with other memory traces.

Most of the heavy lifting in the Legion core language occurs in the function call expression.
The expressions for all the function's arguments are evaluated in the caller's context, but a
new context is assembled for the evaluation of the function's body.  The region mapping used
in the callee only uses the caller's mapping indirectly - the only logical region names available
are those over which the called function is quantified.  Similarly, the set of local values is
replaced with a mapping of formal parameter names to the values of the arguments.  The store
is updated to account for side-effects of those argument evaluations.  Finally, if the function
being called operates with relaxed coherence (i.e. either {\em atomic} or {\em simult} instead of
{\em excl}), the locations with relaxed coherence are added to the clobber set, allowing the
impact of concurrent modifications of the store to be handled by the caller.  This is done by
annotating the called function's memory trace with the relaxed coherence on a per-location basis
and using the {\em valid\_interleave} predicate to control what parallel execution is allowed.

\begin{figure*}
\centering{
$
\begin{array}{lll}
apply(S, []) & = & S \\
apply(S, E \dplus [ read(l, c, v) ]) & = & apply(S, E) \\
apply(S, E \dplus [ write(l, c, v) ]) & = & apply(S, E)[v/l] \\
apply(S, E \dplus [ reduce_{id}(l, c, v) ]) & = & S'[id(S'(l), v)/l], \text{ where } S' = apply(S, E) \\
mark\_coherence([], \hat Q) & = & [] \\
mark\_coherence(E \dplus [ op(l, c, v) ], \hat Q) & = & mark\_coherence(E, \hat Q) \dplus \\
& & op(l, c', v), \text{ where } \\
& & c' =
\begin{cases}
simult, & \text{if }\exists \rho. l \in \rho \wedge simult(\rho) \in \hat Q \\
atomic, & \text{if }\exists \rho. l \in \rho \wedge atomic(\rho) \in \hat Q \\
excl, & \text{otherwise}
\end{cases} \\
any\_interleave(E', [], \ldots, []) & \rightarrow & true \\
any\_interleave([ op(l, c, v) ] \dplus E', E_1, \ldots, [ op(l, c, v) ] \dplus E_i, \ldots, E_n) & \rightarrow & any\_interleave(E', E_1, \ldots, E_i, \ldots, E_n) \\
valid\_interleave(S, C, E', \oton{E}) & \rightarrow & any\_interleave(E', \oton{E}) \\
valid\_interleave(S, C, E' \dplus [ read(l, c, v) ] \dplus E'', \oton{E}) & \rightarrow & l \in C \vee S'(l) = v, \text{ where } S' = apply(S, E')
\end{array}
$}
\caption{Operational Semantics Helper Functions}
\label{fig:opsemfns}
\end{figure*}

\begin{figure*}
\centering{\small
\framebox{$\opsenvx bv \mapsto bv, []$}
\framebox{$\opsenvx iv \mapsto iv, []$}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S' = apply(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx \langle e_1, e_2 \rangle \mapsto \langle v_1, v_2 \rangle, E'}
\finfrule
{\opsenvx e \mapsto \langle v_1, v_2 \rangle, E}
{\opsenvx e\text{.1} \mapsto v_1, E} \hspace{1cm}
\finfrule
{\opsenvx e \mapsto \langle v_1, v_2 \rangle, E}
{\opsenvx e\text{.2} \mapsto v_2, E}
\finfrule
{L(id) = v}
{\opsenvx id \mapsto v, []}
\framebox{$\opsenvx \text{null }T@r \mapsto null, []$}
\finfrule
{\begin{array}{l}
l \in M(r) \\
H(l) = M \llbracket T \rrbracket
\end{array}}
{\opsenvx \text{new }T@r \mapsto l, []}
\finfrule
{\opsenvx e \mapsto l, E}
{\opsenvx \text{isnull}(e) \mapsto \textit{false}, E}
\finfrule
{\opsenvx e \mapsto null, E}
{\opsenvx \text{isnull}(e) \mapsto true, E}
\finfrule
{\opsenvx e \mapsto v, E}
{\opsenvx \text{upregion}(e, \oton{r}) \mapsto v, E}
\finfrule
{\begin{array}{l}
\opsenvx e \mapsto l, E \\
v = \begin{cases}
l, & \text{if $\exists i, l \in M(r_i)$}. \\
null, & \text{otherwise}.
\end{cases}
\end{array}}
{\opsenvx \text{downregion}(e, \oton{r}) \mapsto v, E}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto l, E \\
S' = \text{apply}(S, E) \\
v = \begin{cases}
S'(l), & \text{if } l \not\in C \\
v' : H(l), & \text{otherwise}
\end{cases}
\end{array}}
{\opsenvx \text{read}(e_1) \mapsto v, E \dplus [ read(l, excl, v) ]}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto l, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto v, E_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx \text{write}(e_1, e_2) \mapsto true, E' \dplus [ write(l, excl, v) ]}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto l, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto v, E_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx \text{reduce}(id, e_1, e_2) \mapsto true, E' \dplus [ reduce_{id}(l, excl, v) ]}
\framebox{$\opsenvx \text{newcolor }r \mapsto \emptyset, []$}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto K, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto l, E_2 \\
S'' = \text{apply}(S', E_2) \\
\opsenvx[S=S''] e_3 \mapsto v, E_3 \\
K' = \{ (l,v) \} \cup \{ (l_i,v_i) : (l_i,v_i) \in K \wedge l \not= l_i \} \\
valid\_interleave(S, C, E', E_1, E_2, E_3)
\end{array}}
{\opsenvx \text{color}(e_1, e_2, e_3) \mapsto K', E'}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2 \\
v' = v_1 + v_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx e_1 + e_2 \mapsto v', E'}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2 \\
v' = \begin{cases}
true, & \text{if $v_1 < v_2$}. \\
\textit{false}, & \text{otherwise}.
\end{cases} \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx e_1 < e_2 \mapsto v', E'}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
L' = L[v_1/id] \\
S' = \text{apply}(S, E_1) \\
\opsenvx[L=L',S=S'] e_2 \mapsto v_2, E_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx \text{let }id : T = e_1\text{ in }e_2 \mapsto v_2, E'}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto true, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_2 \mapsto v_2, E_2
\end{array}}
{\opsenvx \text{if }e_1\text{ then }e_2\text{ else }e_3 \mapsto v_2, E_1 \dplus E_2}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto \textit{false}, E_1 \\
S' = \text{apply}(S, E_1) \\
\opsenvx[S=S'] e_3 \mapsto v_3, E_3
\end{array}}
{\opsenvx \text{if }e_1\text{ then }e_2\text{ else }e_3 \mapsto v_3, E_1 \dplus E_3}
\finfrule
{\begin{array}{l}
\opsenvx e_1 \mapsto v_1, E_1 \\
S_1 = \text{apply}(S, E_1) \\
\opsenvx e_2 \mapsto v_2, E_2 \\
\ldots \\
S_n = \text{apply}(S_{n-1}, E_n) \\
valid\_interleave(S, C, E', \oton{E})
\vspace{1.5mm} \\
\text{task }id[\otok{k}{r'}](a_1 : T_1, \ldots, a_n : T_n), \Phi', Q' : T_r = e_{n+1} \\
M' = \{ (r'_1, M(r_1)), \ldots (r'_k, M(r_k)) \} \\
L' = \{ (a_1, v_1), \ldots, (a_n, v_n) \} \\
S' = \text{apply}(S, E') \\
C' = C \cup \{ l : \exists \rho. atomic(\rho) \in M' \llbracket Q' \rrbracket \vee simult(\rho) \in M' \llbracket Q' \rrbracket \} \\
\opsenvx[M=M',L=L',S=S'] e_{n+1} \mapsto v_{n+1}, E_{n+1}
\vspace{1.5mm} \\
E'_{n+1} = mark\_coherence(E_{n+1}, M' \llbracket Q' \rrbracket) \\
valid\_interleave(S, C, E'', E', E_{n+1})
\end{array}}
{\opsenvx id[\otok{k}{r}](\oton{e}) \mapsto v_{n+1}, E''}
\finfrule{
\begin{array}{l}
\opsenvx e_1 \mapsto K, E_1 \\
\rho_i = \{ l : (l, i) \in K \}, \text{ for } 1 \leq i \leq k \\
M' = M[\rho_1/r_1, \ldots, \rho_k/r_k] \\
S' = \text{apply}(S, E_1) \\
\opsenvx[M=M',S=S'] e_2 \mapsto v, E_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx \text{partition}\ r_p\text{ using }e_1\text{ as }\otok{k}{r}\text{ in }e_2 \mapsto v, E'}
\finfrule{
\begin{array}{l}
\opsenvx e_1 \mapsto v, E \\
\rho_i = M[r_i], \text{ for } 1 \leq i \leq k \\
v' = \langle \langle \otok{k}{\rho}, v \rangle \rangle
\end{array}}
{\opsenvx \text{pack}\ e_1\ \text{as}\ T_1[\otok{k}{r}] \mapsto v', E}
\finfrule{
\begin{array}{l}
\opsenvx e_1 \mapsto \langle \langle \otok{k}{\rho} , v_1 \rangle \rangle, E_1 \\
M' = M[\rho_1/r_1, \ldots, \rho_k/r_k] \\
L' = L[v_1/id] \\
S' = \text{apply}(S, E_1) \\
\opsenvx[M=M',L=L',S=S'] e_2 \mapsto v_2, E_2 \\
valid\_interleave(S, C, E', E_1, E_2)
\end{array}}
{\opsenvx \text{unpack}\ e_1\ \text{as}\ id : T_1[\otok{k}{r}] \text{in}\ e_2 \mapsto v_2, E' }
}
\caption{Legion Core Operational Semantics}
\label{fig:semantics}
\end{figure*}

\subsection{Soundness of Effects}

An important property of the legion type system is that any expression that is well-typed is
guaranteed to access the heap only in ways permitted by the privileges under which it was typed.
A judgement $M \vdash E : \Phi$ holds if all the memory operations in $E$ are of the types and
to locations covered by the privileges in $\Phi$:

\begin{center}
\begin{tabular}{l@{ }l@{ }l}
$M \vdash E : \Phi$ & $\Leftrightarrow$ & $\forall \epsilon\text { in } E.$ \\
& & $(\epsilon = read(l, c, v) \rightarrow \exists r. l \in M(r) \wedge reads(r) \in \Phi)\ \wedge$ \\
& & $(\epsilon = write(l, c, v) \rightarrow \exists r. l \in M(r) \wedge writes(r) \in \Phi)\ \wedge$ \\
& & $(\epsilon = reduce_{id}(l, c, v) \rightarrow \exists r. l \in M(r) \wedge reduces(id, r) \in \Phi)$
\end{tabular}
\end{center}

The proof that $M \vdash E : \Phi$ holds for all well-typed Legion expressions is achieved by
induction over the structure of the expression.  Soundness is contingent on the following
consistent properties, which must be shown to hold for each subexpression:
\begin{itemize}
\item $M \sim \Omega$, a region mapping must satisfy the region constraints under which the expression was typed
\item $L \sim_H \Gamma$, the local values must have types consistent with the environment under which the expression was typed
\item $S \sim H$, the initial state of the store must contain values whose types are consisten with the heap typing
\end{itemize}

The proof requires two additional properties be proved for each subexpression:
\begin{itemize}
\item $v \sim_H M \llbracket T \rrbracket$, a subexpresion must evaluate to a value of the right type
\item $E \sim H$, the values written to the store must match the heap types of the location to which they're stored
\end{itemize}
Figure~\ref{fig:constprop} gives the precise definition of these properties.

\begin{figure*}
\centering{\footnotesize
$
\begin{array}{l}
\begin{array}{ll}
\begin{array}{lll}
M \sim \Omega & \Leftrightarrow & (\forall r_i, r_j. r_i \leq r_j \in \Omega \rightarrow M(r_i) \subseteq M(r_j))\ \wedge \\
              &                 & (\forall r_i, r_j. r_i * r_j \in \Omega \rightarrow M(r_i) \cap M(r_j) = \emptyset) \\
L \sim_H \Gamma & \Leftrightarrow & \forall (id,v) \in L. v \sim_H M \llbracket \Gamma \rrbracket (id) \\
S \sim H & \Leftrightarrow & \forall (l,v) \in S. v \sim_H H(l) \\
\end{array} & 
\begin{array}{lll}
E \sim H & \Leftrightarrow & (\forall l, c, v. write(l,c, v) \in E \rightarrow v \sim_H H(l))\ \wedge \\
& & (\forall id, l, v. reduce_{id}(l, v) \in E \rightarrow \\
& & (M \llbracket \Gamma \rrbracket (id) = (\hat T_1, \hat T_2), \emptyset, \emptyset \rightarrow \hat T_1) \wedge H(l) = \hat T_1 \wedge v \sim_H \hat T_2) \\
\end{array}
\end{array} \vspace{3mm} \\
\begin{array}{l@{\hspace{1cm}}l}
\begin{array}{l}
bv \sim_H bool \\
iv \sim_H int \\
null \sim_H \hat T@\rho \\
\end{array} &
\begin{array}{lll}
l \sim_H \hat T@\rho & \Leftrightarrow & l \in \rho \wedge H(l) \sim_H \hat T \\
\langle v_1, v_2 \rangle \sim_H \langle \hat T_1, \hat T_2 \rangle & \Leftrightarrow & (v_1 \sim_H \hat T_1) \wedge (v_2 \sim_H \hat T_2) \\
\langle \langle \oton{\rho}, v \rangle \rangle \sim_H \text{rr}[\oton{r}] \hat T\text{ where }\Omega & \Leftrightarrow & (v \sim_H \hat T[\rho_1/r_1, \ldots \rho_n/r_n]) \wedge (\{ (r_i, \rho_i) \} \sim \Omega) \\
K \sim_H coloring(\rho) & \Leftrightarrow & \forall l_1, v_1. (l_1, v_1) \in K \rightarrow (l_1 \in \rho\ \wedge \\
& & \forall l_2, v_2. (l_2, v_2) \in K \rightarrow (l_1 \not= l_2) \vee (v_1 = v_2)) \\
\end{array}
\end{array}
\end{array}
$
}
\caption{Consistency Properties}
\label{fig:constprop}
\end{figure*}

\begin{thm}
For any expression $e$, if:
\begin{center}
$
\begin{array}{l} \\
\typeenv{e}{T} \\
\opsenv{e}{v}{E} \\
M \sim \Omega \\
L \sim_H \Gamma \\
S \sim H
\end{array}
$
\end{center}
then:
\begin{center}
$
\begin{array}{l}
v \sim_H M \llbracket T \rrbracket \\
E \sim H \\
M \vdash E : \Phi
\end{array}
$
\end{center}
\end{thm}

Although there are 23 different cases to be proven, many of them are similar, and benefit from
the use of the following lemmas:

\begin{lem}
\label{lemma:heapconst:apply}
If $S \sim H$ and $E \sim H$, then $\text{apply}(S, E) \sim H$.
\end{lem}

\begin{lem}
\label{lemma:heapconst:effects1}
If $E_1 \sim H$ and $E_2 \sim H$, then $E_1 \dplus E_2 \sim H$.
\end{lem}

\begin{lem}
\label{lemma:heapconst:effects2}
If $E_1 \sim H$ and $E_2 \sim H$ and $valid\_interleave(S, C, E', E_1, E_2)$, then $E' \sim H$.
\end{lem}

\begin{lem}
\label{lemma:effsound:effects1}
If $M \vdash E_1 : \Phi$ and $M \vdash E_2 : \Phi$, then $M \vdash E_1 \dplus E_2 : \Phi$.
\end{lem}

\begin{lem}
\label{lemma:effsound:effects2}
If $M \vdash E_1 : \Phi$ and $M \vdash E_2 : \Phi$ and $valid\_interleave(S, C, E', E_1, E_2)$, then $M \vdash E' : \Phi$.
\end{lem}

\begin{lem}
\label{lemma:omegaclosure}
$M \sim \Omega^*$ if and only if $M \sim \Omega$.
\end{lem}

\begin{lem}
\label{lemma:phiclosure}
$M \vdash E : \Phi^*$ if ant only if $M \vdash E : \Phi$.
\end{lem}

The complete soundness proof can be found here\cite{xyz} - for space reasons we just discuss
the general strategy here.

\begin{itemize}

\item Only three expressions have subexpressions that modify $M$ or $\Omega$.  For the
{\em partition} expression, the assumed consistency of the coloring can be shown to preserve
the region mapping consistency with respect to the constraints.  Similarly, the consistency of 
a region relation instance guarantees the maintenance of consistency in an {\em unpack}
expression.  Finally, the body of a called function executes with a different region mapping,
but with an initially-empty set of constraints, so they are trivially satisfied.

\item Only three expression have subexpressions that modify $L$, $\Gamma$, $M$.  The
{\em partition} expression only modifies $M$, and the requirement that it not reuse existing
names ensures that $M \llbracket \Gamma \rrbracket$ does not change.  The value and type of the
binding created in a {\em let} expression is obviously consistent, while the binding created in
an {\em unpack} expression is less obviously so, requiring an induction over the type of the 
unpacked value to show equivalence under the new mapping.  The last case is again the body of a
called function, which requires the same style of proof as for the {\em unpack} expression to
be performed for each formal parameter.

\item The heap typing consistency of all stores used in subexpressions follows directly from
Lemma~\ref{lemma:heapconst:apply}.

\item With the necessary consistency conditions all satified, the inductive hypothesis asserts
the type consistency of all subexpression result values.  The consistency of the result of 
the {\em upregion} is guaranteed by the type checking requirement of appropriate subregion
constraints and the mapping's consistency with those constraints, whereas {\em downregion}
expression's result is consistent due to the run time check that is performed.  (The requirement
for appropriate constraints in the {\em downregion} typing rule is primarily for performance
(i.e. knowing which part of the region tree to examine) and to catch downcasts that will never
work at runtime.)

The consistency of a {\em read} expression's result is trivial when an address falls in the
clobber set, and counts on the consistency of the store otherwise.  The consistency of a 
{\em color} expression's result depends on the pointer subexpression's consistency and the 
removal of any previous coloring of that location from the coloring set.  The remaining
interesting cases arise from changes to the mapping $M$ rather than transformations on the
value $v$.  In the case of {\em partition} and {\em unpack} expressions, the type system's
requirement that the body subexpression's result not use the regions that were added to the
mapping allow the changes to the mapping to be ignored.  The last case is, yet again, the body
of a called function, and the same strategy that was used for the type consistency of the
formal parameters works in reverse for the function's result.

\item The type consistency of the value in an expression's effect follows from
Lemmas~\ref{lemma:heapconst:effects1} and~\ref{lemma:heapconst:effects2}.  New effects are
added by the {\em write} and {\em reduce} expressions, but their values' consistency follows
directly from the inductive hypothesis on their subexpressions.  Finally, the consistency of the
values in a called function's memory trace is addressed in the same way as the return value.

\item The proof of the crucial property of containment of effects within the available privileges
is very similar to the previous step, with Lemmas~\ref{lemma:effsound:effects1}
and~\ref{lemma:effsound:effects2} covering most cases, straightforward proofs for the {\em read},
{\em write}, and {\em reduce} expressions, and one final special case for function calls.  The 
inductive hypothesis asserts that the function body's effects are contained within its own
privileges.  Those are a subset of the caller's $\Phi^*$, and then Lemma~\ref{lemma:phiclosure}
is used to complete the proof.
\end{itemize}

modify $M$
\begin{table*}
\centering
{\small
\begin{tabular}{l|p{5cm}|p{5cm}|p{5cm}}
{\bf Rule} & 
\multicolumn{1}{|c|}{$\mathbf{v \sim_H M \llbracket T \rrbracket}$} &
\multicolumn{1}{|c|}{$\mathbf{E \sim H}$} &
\multicolumn{1}{|c|}{$\mathbf{E : \Phi}$} \\
\hline
BoolConst & & & \\
IntConst & & & \\
TupleBuild & & & \\
TupleField & & & \\
LocalVar & & & \\
NullPtr & & & \\
NewPtr & & & \\
IsNull & & & \\
UpRegion & & & \\
DownRegion & & & \\
Read & & & \\
Write & & & \\
Reduce & & & \\
Newcolor & & & \\
Color & & & \\
IntMath & & & \\
IntCmp & & & \\
Let & & & \\
IfElse & & & \\
TaskCall & & & \\
Partition & & & \\
Pack & & & \\
Unpack & & &
\end{tabular}}
\caption{Proof pieces}
\end{table*}


\subsection{Noninterference}

The soundness proof above depended, in part, on the properties of a valid interleaving of two
memory traces.  We now consider algorithms that create interleavings that satisfy those
conditions.

The simplest way to achieve a valid interleaving is to concatenate the traces in order.  This
will always result in a valid interleaving, but implies a serialization of the evaluation of
subexpressions.

\framebox{$\forall S, C, E_1, E_2. valid\_interleave(S, C, E_1 \dplus E_2, E_1, E_2)$}

Next step: For noninterfering traces $E_1 \# E_2$, show any interleaving is valid.

Third step: For interactions only on atomic-coherence locations, serializability is sufficient.

For a given expression $e$, we can consider $v^o$ to be a ``sequential'' result and $E^o$ to be the corresponding ``sequential'' effects if: \\

\framebox{$M, L, H, S, \emptyset \vdash e \mapsto v^o, E^o$} \\

(i.e. if there are no manipulations of the store other than what's done by
the evaluation of the expression $e$.)  We now wish to consider what parallel
evaluations of this expression with other expression evaluations will still
yield our ``sequential'' result. \\

Two effects are considered to be noninterfering, written $E_1 \# E_2$ if for
every $\epsilon_1$ in $E_1$ and every $\epsilon_2$ in $E_2$,
\begin{enumerate}
\item $\epsilon_1$ and $\epsilon_2$ are to different memory locations, or
\item $\epsilon_1 = read(l, v_1)$ and $\epsilon_2 = read(l, v_2)$, or
\item $\epsilon_1 = reduce_{id}(l, v_1)$ and $\epsilon_2 = reduce_{id}(l, v_2)$
\end{enumerate}

We define nonintereference (under a given mapping $M$) of static privileges
$\Phi_1$ and $\Phi_2$ similarly.  We use the following table for determining
noninterference of two individual priviledges $\phi_1$ and $\phi_2$:

\begin{tabular}{ccccc}
\multicolumn{2}{l}{$\phi_1 \#_M \phi_2 ?$} & \multicolumn{3}{c}{$\phi_2$} \\
\multicolumn{2}{l}{} & $reads(r_2)$ & $writes(r_2)$ & $reduces(id_2, r_2)$ \\
\multirow{3}{*}{$\phi_1$} & $reads(r_1)$ & true & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$\\
& $writes(r_1)$ & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$ \\
& $reduces(id_1, r_1)$ & $M(r_1) \cap M(r_2) = \emptyset$ & $M(r_1) \cap M(r_2) = \emptyset$ & $\begin{array}{l}id_1 = id_2 \vee \\ M(r_1) \cap M(r_2) = \emptyset\end{array}$
\end{tabular}

We can then define: \\

\framebox{$\Phi_1 \#_M \Phi_2 \Leftrightarrow \displaystyle\bigwedge_{\begin{array}{c}\phi_1 \in \Phi_1 \\ \phi_2 \in \Phi_2 \end{array}} \phi_1 \#_M \phi_2$} \\

From the soundness of effects, result, we can show that for two expressions
$e_1$ and $e_2$, if their privileges are noninterfering, any potential memory
traces from their evaluation must also be noninterfering.  Formally:

\finfrule
{\begin{array}{l}
\typeenvx[P=\Phi_1] e_1 : T_1 \\
\typeenvx[P=\Phi_2] e_2 : T_2 \\
\opsenvx e_1 \mapsto v_1, E_1 \\
\opsenvx e_2 \mapsto v_2, E_2 \\
\Phi_1 \#_M \Phi_2
\end{array}}
{E_1 \# E_2}

(TODO: Generalize this further and allow $M_1 \not= M_2$?) \\

Note that this result holds even if $C \not= \emptyset$.  This allows 
two ``locally independent'' subtasks to run in parallel even if one or both
of them is interacting (in a programmer-permitted way) with a third subtask.

Noninterference of effects is something that can only be determined after
evaluation of an expression is completed, and only at great expense (see STM).
In contrast, the noninterference of privileges can be efficiently determined at
runtime.  Even though the privileges themselves are static, the
mapping $M$ can be dynamically determined, allowing noninterference to be 
judged in many more cases than a purely static analysis can achieve.

(TODO: Talk about coherence modes and how the runtime orders subtasks.  Maybe
describe it in terms of a ``canonical'' memory trace and then allow
reorderings?)

\subsection{Hierarchical Scheduling}

Let $e_1$ and $e_2$ be expressions that require privileges $\Phi_1$ and
$\Phi_2$.  Now let $e_3$ be some subexpression of $e_1$ and $e_4$ be some 
subexpression of $e_2$, with corresponding privileges $\Phi_3$ and $\Phi_4$.

Proper scheduling of the evaluation of $e_3$ and $e_4$ depends on whether
they interfere.  If they do intefere (and must therefore be serialized), we
will have $E_3 \cancel\# E_4$, and by the above result, $\Phi_3 \cancel\# \Phi_4$. 

We now show that this will also imply that $\Phi_1 \cancel\# \Phi_2$, and
unless sequential behavior has been relaxed by the programmer, the
evaluations of $e_1$ and $e_2$ will be serialized.  Since the evaluation of
$e_3$ is a subsequence of the evaluation of $e_1$ and the evaluation of $e_4$
is a subsequence of the evaluation of $e_2$, the evaluations of $e_3$ and $e_4$
are properly serialized as well.

Conversely, if $e_1$ and $e_2$ are judged to be noninterfering, the schedule
does not need to check for interference between $e_3$ and $e_4$, as their
noninterference is guaranteed.

Proof is straightforward once armed with the following lemmas:

\framebox{$\Phi_1 \#_M \Phi_2 \Leftrightarrow \Phi_1^* \#_M \Phi_2^*$}

\framebox{$\Phi_1 \#_M \Phi_2 \wedge \Phi_3 \subseteq \Phi_2 \Rightarrow \Phi_1 \#_M \Phi_3$}

