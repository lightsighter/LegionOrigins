
\section{Execution Model}
\label{sec:exec}

In this section we present the Legion execution model and argue that
it is correct in that it is guaranteed to preserve the sequential
execution semantics of programs.  The correctness argument is
instructive in that the properties that ensure correctness are also
exploited in the implementation of the Legion high-level runtime
system to achieve high performance and highly distributed scheduling
of parallel tasks.

For the purposes of describing and reasoning about the
execution model we consider an extremely restricted core language, so
simple in fact that it is not even Turing complete and is also extremely
inconvenient for writing programs.  The loss in expressive power, however,
is hopefully a gain in clarity and simplicity for illustrating the core ideas in
Legion.    We consider programs written in the following language:

\begin{eqnarray*}
F & := & \mbox{def}\ f(r_1,\ldots,r_n): P_1,\ldots,P_m  =   s_1; \ldots s_n; \\[.15in]
P & := & R(r) | W(r) \\[.15in]
s & := & f(r_1,\ldots,r_n) \\
&| & \deref r = x \\
& | & x = \deref r \\
&| & \mbox{\tt newregion}\ r \\
&| & (r_1, r_2)_{p} = \mbox{\tt partition}(r) \\ 
&| & \mbox{\tt close}\ p 
\end{eqnarray*}

There are four kinds of names: functions $f$, regions $r$, local
variables $x$, and partitions $p$.  A function takes a number of
regions as arguments and the function definition $f$ specifies the
region permissions $f$ requires; the permission $R(r)$ means $f$ may
read $r$, and $W(r)$ means $f$ may write $r$.  

A function body consists of an ordered list of statements.  The statement
$f(r_1,\ldots,r_n)$ calls a function, which is executed for its effects
on its region arguments.  The statement $x = \deref
r$ reads a value from region $r$ and stores it in local variable $x$,
and the statement $\deref r = x$) stores the value of $x$ in region
$r$.  A $\mbox{\tt newregion} r$ statement creates a new region with
name $r$. 

The statement $(r_1, r_2)_{p} = \mbox{\tt partition}(r)$
creates two {\em subregions} $r_1$ and $r_2$ partitioning the parent
region $r$.  All three region names ($r_1$,$r_2$,and $r$) can be used
after the partition.  Regions $r_1$ and $r_2$ are disjoint but neither
$r_1$ nor $r_2$ is disjoint from $r$.  The partition itself also has a name $p$,
which is used to {\em close} the partition in the $\mbox{\tt close}\ p$ statement 
Intuitively, closing a partition reconciles modifications to the subregions with the {\em parent} region: 
$r$ is updated to incorporate any changes to $r_1$ and $r_2$.  In our source language {\tt close} is not
available to the programmer, but is invoked by the language implementation to reconcile distributed copies
of regions whenever necessary, and it is impossible for the program to observe discrepencies between
a region and its subregions. This toy language, then, is closer to the level of ourintermediate representation,
which is most appropriate for discussing our runtime system.

A program is a list of functions, with the entry point the first function on the list.
We further require that every function except the entry poiint be called in exactly one place
and to have its formal parameters be identical to the actual parameters in its single call.
Region names in {\tt newregion} and partition names in {\tt partition} are chosen to be distinct from
all other region/partition names in the program.  These restrictions allow us to avoid dealing with
alpha renaming and also mean that each runtime call is uniquely named by its function name.












