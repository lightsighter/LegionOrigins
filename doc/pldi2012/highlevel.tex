
\section{High-Level Runtime} 
\label{sec:highlevel}
The high-level runtime is responsible for guaranteeing the semantics 
of programs written in the Legion programming model while at the same
time extracting high performance.  This goal is challenging because
the high-level runtime must be capable of operating on top of many 
different architectures abstracted by the low-level runtime.  This 
includes those with very large latencies for transferring data such
as distributed memory clusters.  To hide these latencies, the high
level runtime uses a deffered model of execution made possible by the
event model of the low-level runtime.  By deffering execution, the 
runtime can hide the latencies of data and task movement and acieve
good throughput and high performance.

However, a deffered execution model presents challenges to implementing
the semantics of the Legion programming model.  Deffered execution
does not necessarily imply that tasks will be executed in the order in
which they are scheduled, but only in the order in which low-level
event dependencies are created.  To orchestrate the execution of Legion
programs in this environment the high-level runtime is architected
in a manner similar to an out-of-order hardware processor.  There are
multiple stages to executing a task which allows the runtime to extract
as much task-level parallelism as possible from an application whithin
the constraints of the Legion programming model.  We now investigate
each of these stages in further detail.

\subsection{Dependence Analysis} 
\label{subsec:dep_analysis}
The first step in the execution of a task is dependence analysis.  When
a task is registered with the high level runtime the task call includes
information about both the logical regions that the task will require
when it is executed as well as the read-write access and coherence properties
for each of the regions.  The runtime uses this information to perform
conflict detection with each of the previous tasks that have been registered
in the same parent task.  Conflict detection only needs to be performed at
the scope of an enclosing task because the semantics of the Legion programming
model ensure that all tasks can only use regions which are subregions of
regions that the parent task uses.  This implies that if a child task were
to have a conflict with task at a higher level of the task tree, then the
parent task would also have had a conflict.  

Lemma: If a task {\tt t} with ancestor task {\tt p} conflicts with task {\tt t'}
a sibling task of {\tt p}, then tasks {\tt p} and {\tt t'} must conflict.

This property of the Legion programming model enables the runtime to only 
have to perform dependence analysis between tasks which share the same 
parent task.  By restricting dependence analysis to tasks which share the same
parent task, the runtime can perform dependence analysis locally and not
have to be concerned with tasks being created in other parts of the machine.

\subsubsection{Detecting Dependences}
\label{subsec:dep_detect}
To detect dependences between the tasks, the runtime leverages its knowledge
about logical regions and their partitions.  To create a new logical region
or partition, the application must invoke the corresponding call in the
runtime.  As these calls occur, the runtime constructs a data strcture
called a {\em region tree}.  A region tree describes the relationship between
logical regions and partitions.  A region tree contains two types of nodes:
region nodes and partition nodes.  Every region tree is rooted with a region
node and alternates between region and partition nodes each corresponding level.
A region node represents a specific logical region and tracks the set of
partitions of that logical region.  Similarly a partition node represents 
a specific partitioning of a region and keeps track of the logical regions 
which are subregions of the partition.

For every task, the runtime keeps track of the subset of region trees that
the task uses.  

\subsubsection{Managing Region Trees}

\subsection{Mapping}

\subsubsection{Placing Tasks}

\subsubsection{Tracking Instances}

\subsection{Execution}

\subsection{Task Completion}
